---
title: 01. Kotlin 基本语法
date: 2022-10-07 21:44:00
updated: 2022-10-07 21:44:00
categories:
  - 语言
  - Kotlin
tags:
- kotlin
---

## 注释

Kotlin 程序有 3 类注释：单行注释（//）、多行注释（/*...*/）和文档注释（/**...*/）。注释方法与 Java 语言都类似。

## 标识符

标识符就是变量、常量、函数、属性、类、接口和扩展等由程序员指定的名字。构成标识符的字符均有一定的规范，Kotlin 语言中标识符的命名规则如下：

* 区分大小写：Myname 与 myname 是两个不同的标识符。
* 首字符，可以是下划线（_）或字母，但不能是数字。
* 除首字符外其他字符，可以是下划线（_）、字母和数字。
* 硬关键字（Hard Keywords）不能作为标识符，软关键字（Soft Keywords）、修饰符关键字（Modifier Keywords）在它们的适用场景之外可以作为标识符使用。
* 特定标识符 field 和 it。在 Kotlin 语言中有两个由编译器定义的特定标识符，它们只能在特定场景中使用有特定的作用，而在其他的场景中可以做标识符使用。

提示　如果一定要使用关键字作为标识符，可以在关键字前后添加反引号（`）。另外，Kotlin语言中字母采用的是双字节 Unicode 编码。Unicode 叫作统一编码制，它包含了亚洲文字编码，如中文、日文、韩文等字符。

## 关键字

关键字是类似于标识符的保留字符序列，由语言本身定义好的，Kotlin 语言中有 70 多个关键字，全部是小写英文字母，以及 ! 和 ? 等字符构成。分为 3 个大类：

1. 硬关键字（Hard Keywords），硬关键字如何情况下都不能作为关键字，具体包括如下关键字。
as、as?、break、class、continue、do、else、false、for、fun、if、in、!in、interface、is、!is、null、object、package、return、super、this、throw、true、try、typealias、val、var、when和while。
2. 软关键字（Soft Keywords），软关键字是在它适用场景中不能作为标识符，而其他场景中可以作为标识符，但为例避免误解，一般也不会这么用。具体包括如下关键字。
by、catch、constructor、delegate、dynamic、field、file、finally、get、import、init、param、property、receiver、set、setparam 和 where。
3. 修饰符关键字（Modifier Keywords），修饰符关键字是一种特殊的软关键字，它们用来修饰函数、类、接口、参数和属性等内容，在此场景中不能作为标识符。而其他场景中可以作为标识符，具体包括如下关键字。
abstract、annotation、companion、const、crossinline、data、enum、external、final、infix、inner、internal、lateinit、noinline、open、operator、out、override、private、protected、public、reified、sealed、suspend、tailrec和vararg。

### in和!in 关键字

判断一个数值是否在区间中可以使用in关键字。而!in关键字，则是判断一个值不在区间中。此外，这两个关键字（in和!in）还可以判断一个数值是否集合或数组中。

```kt
if (testscore !in 60..100) { //使用!in关键字
    println("不及格")
}
val strArray = arrayOf("刘备", "关羽", "张飞")
val name = "赵云"
if (name !in strArray) {
    println(name + "不在队伍中")
}
```

## 常量和变量

Kotlin 有强大的类型推断能力。虽然你可以显式地声明变量的类型，但通常会让编译器通过推断来完成这项工作。Kotlin 并不强制执行不变性，尽管它是被推荐的。本质上使用 val/var。

在 Kotlin 中声明变量，就是在标识符的前面加上关键字 var。
变量一旦赋值就不能更改。要声明只读变量，使用 val 关键字。常量一旦初始化后就不能再被修改。

```kt
// kotlin 可自动推断变量类型
var y = 20
// 声明并指定数据类型
var scoreForStudent: Float = 0.0f
```

### 使用 var 还是 val

如果两种方式都能满足需求情况下，原则上优先考虑使用 val 声明。因为一方面 val 声明的变量是只读，一旦初始化后不能修改，这可以避免程序运行过程中错误地修改变量内容；另一方面在声明引用类型使用 val，对象的引用不会被修改，但是引用内容可以修改，这样会更加安全，也符合函数式编程的技术要求。

注意：你可以自由选择何时初始化变量，但是，它必须在第一次读之前初始化。

```kt
val d: Int  // 1

if (someCondition()) {
    d = 1   // 2
} else {
    d = 2   // 2
}

println(d) // 3
```

### 编译时常量

编译时常量使用 const val 进行修饰。

编译时常量只能在函数（指包括 main 在内的所有函数）之外定义。这是因为编译时常量 必须在编译时（程序编译时）赋值，而 main 和其他函数都是在运行时（程序运行时）才调用， 函数内的变量也是在那时赋值。编译时常量要在这些变量赋值前就已存在。

因为使用复杂的数据类型可能会危害编译时的安全保障，所以编译时常量只能是一些常见的基本数据类型。

 String  Int  Double  Float  Long  Short  Byte  Char  Boolean

```kt
const val MAX_EXPERIENCE: Int = 5000

fun main(args: Array<String>) {...}
```

## 代码规范

一行代码的长度应尽量不要超过 80 个字符，如果超过则需断行，可以依据下面的一般规范断开：

* 在一个逗号后面断开。一个运算符前面断开，要选择较高级别的运算符（而非较低级别的运算符）断开。

下面通过一些示例说明：

```kt
longName1 = longName2 * (longName3 + longName4 - longName5)
        + 4 * longName6  // ①
longName1 = longName2 * (longName3 + longName4
        - longName5) + 4 * longName6  //②

fun format(obj: Any, toAppendTo: StringBuffer,
                    fieldPosition: FieldPosition): StringBuffer { //③
    ...
}

if ((longName1 == longName2)
         || (longName3 == longName4) && (longName3 > longName4)
         && (longName2 > longName5)) {  //④

}
```

1. 上述代码第 ① 行和第 ② 行是带有小括号运算的表示式，其中代码第 ① 行的断开位置要比第 ② 行的断开位置要好。因为代码第①行断开处位于括号表达式的外边，这是个较高级别的断开。
2. 代码第 ③ 行函数名断开是在参数逗号之后。
3. 代码第 ④ 行是 if 等判断结构表达式中，由于可能有很多长的条件表达式，断开的位置应在逻辑运算符处。

### Coding conventions | Kotlin 代码规范

<https://kotlinlang.org/docs/coding-conventions.html>
