---
title: 三、数据结构
date: 2025-05-05 16:55:00
updated: 2025-05-05 16:55:00
categories: [软件设计师]
---

## 1 线性结构

- 数据结构是程序设计的重要基础，它讨论数据元素集合及其相互关系和构造方法。
- 数据结构分为线性结构和非线性结构，非线性结构包括树结构和图结构。
- 算法设计依赖数据结构，合理数据结构可提升算法效率。

### 1.1 线性表

#### 1.1.1 线性表的定义

- 线性表是 $n(n \geq 0)$ 个元素的有限序列，通常表示为 $(a_1, a_2, \cdots, a_n)$。<!-- more -->
- 非空线性表的特点：
    - 存在唯一的“第一个”元素。
    - 存在唯一的“最后一个”元素。
    - 除第一个元素外，每个元素只有一个直接前驱。
    - 除最后一个元素外，每个元素只有一个直接后继。

#### 1.1.2 线性表的存储结构

##### 1.1.2.1 线性表的存储结构

## 1. 顺序存储

- **定义**：用一组连续存储单元依次存储线性表元素，逻辑相邻则物理相邻。
- **优点**：可随机访问元素。
- **缺点**：插入和删除需移动元素。
- **插入操作**：平均需移动 $\frac{n}{2}$ 个元素。
- **删除操作**：平均需移动 $\frac{n-1}{2}$ 个元素。

##### 1.1.2.2 链式存储

- **定义**：用指针链接结点存储数据元素。
- **基本结构**：每个结点包含数据域和指针域。
- **单链表**：
    - **插入操作**：修改指针。
    - **删除操作**：修改指针并释放空间。
- **查找操作**：从头指针开始顺序查找。
- **插入操作**：在指定位置插入新结点。
- **删除操作**：删除指定位置的结点。
- **优点**：插入和删除无需移动元素。

**变种链表结构**

- **双向链表**：每个结点包含两个指针，分别指向前驱和后继。
- **循环链表**：尾结点指针指向头结点。
- **静态链表**：用数组模拟链表结构。

### 1.2 栈和队列

#### 1.2.1 栈

- **定义**：后进先出（LIFO）的线性表，一端为栈顶，另一端为栈底。
- **基本运算**：
    - 初始化栈 `InitStack(S)`。
    - 判空 `isEmpty(S)`。
    - 入栈 `Push(S, x)`。
    - 出栈 `Pop(S)`。
    - 读取栈顶元素 `Top(S)`。
- **存储结构**：
    - **顺序存储**：用连续存储单元，附设指针 `top`。
    - **链式存储**：用链表，头指针为栈顶指针。
- **应用**：表达式求值、括号匹配、递归处理。

#### 1.2.2 队列

队列是一种先进先出（FIFO）的线性表，元素从队尾插入，从队头删除。其基本运算包括：

- 初始化队列 `InitQueue(Q)`。
- 判空 `isEmpty(Q)`。
- 入队 `EnQueue(Q, x)`。
- 出队 `DelQueue(Q)`。
- 读取队头元素 `FrontQue(Q)`。

**顺序存储**

顺序队列利用连续存储单元存放元素，设置队头指针 `front` 和队尾指针 `rear`。为提高空间利用率，常将顺序队列设计为循环队列。
- 入队操作：`rear = (rear + 1) % MAXSIZE`。
- 出队操作：`front = (front + 1) % MAXSIZE`。
- 特殊情况处理：需区分队空（`front == rear`）和队满（`(rear + 1) % MAXSIZE == front`）。

* **链式存储**：链队列（队列的链式存储）包含头指针和尾指针，便于操作。队空时头指针和尾指针均指头结点。
* **队列的应用**：队列适用于需要排队的场景，如操作系统中的打印任务队列、事件模拟等。

### 1.3 串

#### 1.3.1 串的定义及基本运算

串是字符构成的有限序列，记作 $S = 'a_1a_2 \cdots a_n'$，其中 $S$ 是串名，单引号内是串值。

**基本概念**

- **空串**：长度为 0 的串。
- **空格串**：由一个或多个空格组成的串。
- **子串**：串中任意连续字符的序列，所在位置是首次出现时的第一个字符位置。
- **串相等**：两串长度相等且对应字符相同。
- **串比较**：比较两串大小时，逐字符比较 ASCII 值，较短的串较小。

**基本操作**

- 赋值操作 `StrAssign(s, t)`。
- 连接操作 `Concat(s, t)`。
- 求串长 `StrLength(s)`。
- 串比较 `StrCompare(s, t)`。
- 取子串 `SubString(s, start, len)`。

#### 1.3.2 串的存储结构

* 顺序存储：用连续存储单元存储字符序列，可通过字符数组或动态申请空间实现。
* 链式存储：用链表存储字符，结点可存储一个或多个字符，需考虑存储密度。

#### 1.3.3 串的模式匹配

模式匹配是查找子串（模式串）在主串中的位置，是串处理的重要运算。

##### 1.3.3.1 朴素的模式匹配算法

- **基本思想**：从主串第一个字符开始逐个比较，不匹配则主串指针回退。
- **时间复杂度**：
    - 最好情况：$O(n + m)$。
    - 最坏情况：$O(n \times m)$。

##### 1.3.3.2 改进的 KMP 算法

- **核心思想**：不回退主串指针，利用部分匹配信息移动模式串。
- **关键**：构造 `next` 数组，记录模式串的部分匹配长度。
- **时间复杂度**：$O(n + m)$。

## 2 数组、矩阵和广义表

### 2.1 数组

#### 数组的定义及基本运算

数组是线性表在维数上的扩展，元素类型相同，结构一致。

#### 数组的顺序存储

- **特点**：数组元素数目固定，适合采用顺序存储结构。
- **存储方式**：
  - 行优先存储：按行存储元素。
  - 列优先存储：按列存储元素。
- **地址计算公式(设每个元素占 L 个单元，二维数组有 m 行 n 列)**：
  - 行优先：$\text{Loc}(a_{ij}) = \text{Loc}(a_{11}) + ((i-1) \times n + (j-1)) \times L$
  - 列优先：$\text{Loc}(a_{ij}) = \text{Loc}(a_{11}) + ((j-1) \times m + (i-1)) \times L$

### 2.2 矩阵

矩阵是数组的一种特殊形式，通常用于表示二维数据结构。

#### 特殊矩阵

特殊矩阵是指矩阵中 0 元素（或非 0 元素）的分布有一定规律的矩阵。常见的特殊矩阵包括：

- 对称矩阵：nxn的矩阵中元素都满足 $a_{ij} = a_{ji}$
- 三角矩阵：三对角矩阵的非 0 元素 $a_{ij}$ 仅存在于主对角线及其上下各一条对角线上。
- 对角矩阵：对角矩阵是指矩阵中的非 0 元素都集中在以主对角线为中心的带状区域中。

#### 稀疏矩阵

稀疏矩阵是指矩阵中的非 0 元素远少于 0 元素的矩阵。稀疏矩阵的存储方式有：

- 三元组顺序表
- 十字链表

### 2.3 广义表

广义表是线性表的推广，由 0 个或多个单元素或子表组成的有限序列。广义表一般记为：$LS = (a_1, a_2, \cdots, a_n)$，其中，$a_i$ 可以是单个元素或广义表。

**基本操作**

- **取表头** `head(LS)`：获取广义表的第一个元素。
- **取表尾** `tail(LS)`：获取除第一个元素外的其余元素。

**特点**

1. 可以是多层次的结构，元素可以是子表。
2. 元素可以是已定义的广义表的名字，支持共享。
3. 可以是一个递归的表，元素也可以是本广义表的名字。

**存储结构**

由于广义表的元素可以具有结构，通常采用链式存储结构：

- 表头和表尾指针：用于唯一确定广义表。
- 元素结点：包含标记（tag）和数据指针（hp），用于存储元素值或指向子表。

## 3 树

### 3.1 树与二叉树的定义

#### 3.1.1 树的定义

树是一种非线性结构，由有限个节点组成，满足以下条件：
- 有且仅有一个称为根的节点。
- 其余节点分为 $m (m \geq 0)$ 个互不相交的有限子集 $T_1, T_2, \cdots, T_m$，每个子集本身是一棵树，称为根节点的子树。

树的定义是递归的，表明树由若干棵子树构成，子树又由更小的子树构成。

**树的特点**

- 树中元素之间有严格的层次关系。
- 每个节点最多和上一层的一个节点（双亲结点）有直接关系，和下一层的多个节点（孩子结点）有直接关系。

这种层次结构使得树在描述分类和组织数据时非常有用。

#### 3.1.2 树的基本概念

1. **双亲、孩子和兄弟**：节点的子树的根称为该节点的孩子，该节点称为孩子的双亲，具有相同双亲的节点互为兄弟。
2. **节点的度**： 一个节点的子树个数称为该节点的度。
3. **叶子节点**：度为 0 的节点称为叶子节点或终端节点。
4. **内部节点**：度不为 0 的节点，也称为分支节点或非终端节点。除根节点外，分之节点也称为内部节点。
5. **节点的层次**：根节点为第一层，根的孩子为第二层，依此类推。
6. **树的高度**：树的最大层数称为树的高度。
7. **有序树**：若树中节点的各子树从左到右具有次序，则称为有序树，否则为无序树。

#### 3.1.3 二叉树的定义

二叉树是 n 个节点的有限集合，它或者是空树 $(n = 0)$，或者是由一个根节点及两棵不相交的且分别称为左、右子树的二叉树所组成。二叉树同样具有递归性质。

**二叉树的特点**

- 二叉树中每个节点的子树要区分左子树和右子树，即使在节点只有一棵子树的情况下，也要明确指出该子树是左子树还是右子树。
- 二叉树节点最大度为 2，而树中不限制节点的度数。

### 3.2 二叉树的性质与存储结构

#### 3.2.1 二叉树的性质

1. 第 $i$ 层最多有 $2^{i-1}$ 个结点。
2. 高度为 $k$ 的二叉树最多有 $2^k - 1$ 个结点。
3. 对于任意二叉树，若终端结点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0 = n_2 + 1$。
4. 有 $n$  个结点的完全二叉树的深度为 $\lfloor \log_2 n \rfloor + 1$。

#### 3.2.2 二叉树的存储结构

**顺序存储结构**

- 顺序存储适用于完全二叉树，结点按层次顺序存储。
- 每个结点的双亲、左孩子和右孩子的编号可通过公式计算。

**链式存储结构**

- 链式存储使用二叉链表，每个结点包含数据域和两个指针域。
- 适用于任意二叉树，包括完全二叉树和非完全二叉树。

**节点类型定义**

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
} BiTNode, *BiTree;
```

### 3.3 二叉树的遍历

二叉树的遍历是指按照某种策略访问树中的每个结点，且仅访问一次的过程。二叉树的遍历有三种基本方法：先序遍历、中序遍历和后序遍历。

### 先序遍历（PreOrder）

- 访问顺序：根结点 -> 左子树 -> 右子树
- 函数实现：
  ```c
  void PreOrder(BiTree root) {
     if (root != NULL) {
         printf("%d", root->data);  // 访问根结点
         PreOrder(root->lchild);  // 先序遍历左子树
         PreOrder(root->rchild);  // 先序遍历右子树
     }
  }
  ```

* 中序遍历（InOrder）访问顺序：左子树 -> 根结点 -> 右子树
* 后序遍历（PostOrder）访问顺序：左子树 -> 右子树 -> 根结点
* 非递归中序遍历：使用栈实现非递归中序遍历。

### 3.4 线索二叉树

线索二叉树是对非线性结构进行线性化的过程，使得每个结点（除第一个和最后一个）在这些线性序列中均有一个直接前驱和直接后继。

**建立线索二叉树**

- 增加两个指针域：`ltag`和`rtag`，以区分孩子指针的指向。
- `ltag = 0`：`lchild`域指示结点的左孩子。
- `ltag = 1`：`lchild`域指示结点的直接前驱。
- `rtag = 0`：`rchild`域指示结点的右孩子。
- `rtag = 1`：`rchild`域指示结点的直接后继。

### 3.5 最优二叉树

#### 3.5.1 最优二叉树

最优二叉树（哈夫曼树）是一类带权路径长度最短的树。路径是从树中一个结点到另一个结点之间的通路，路径上的分支数目称为路径长度。

树的带权路径长度（WPL）为从该结点到树根之间的路径长度与该结点权值的乘积之和，记为 $\text{WPL} = \sum_{k=1}^{n} w_k \cdot h_k$。

其中，$n$ 为带权叶子结点数目，$w_k$ 为叶子结点的权值，$h_k$ 为叶子结点到根的路径长度。

**构造最优二叉树的哈夫曼算法**

1. 根据给定的 $n$ 个权值 $\{ w_1, w_2, \cdots, w_n \}$，构成 $n$ 棵二叉树的集合 $F = \{ T_1, T_2, \cdots, T_n \}$，每棵 $T_i$ 中只有一个带权为 $w_i$ 的根结点，其左、右子树均空。
2. 在 $F$ 中选取两棵权值最小的树作为左、右子树构造一棵新的二叉树，重新构造二叉树的根结点的权值为左、右子树根结点的权值之和。
3. 从 $F$ 中删除这两棵树，同时将新得到的二叉树加入到 $F$ 中。
4. 重复步骤 2 和 3，直到 $F$ 中只含一棵树为止，这棵树便是最优二叉树。

#### 3.5.2 哈夫曼编码

哈夫曼编码是一种最优前缀编码方法，用于数据压缩。它通过构造最优二叉树（哈夫曼树）来实现字符的不等长编码。

**构造哈夫曼树**

1. 根据给定的权值集合构造初始的二叉树集合，每棵树只有一个带权根结点，其余结点为空。
2. 选择两棵权值最小的树作为左、右子树构造新树，新树的根结点权值为两棵树根结点权值之和。
3. 重复步骤2，直到集合中只剩一棵树，这棵树即为哈夫曼树。

**编码过程**

- 从哈夫曼树的根结点出发，根据路径上 0 和 1 的不同选择，为每个字符生成编码。
- 左子树路径为 0，右子路径为 1。

**解码过程**

* 从根结点出发，根据编码的二进制位串确定路径，到达叶子结点时输出对应字符。
* 若位串未结束，回到根结点继续译码。

### 3.6 树和森林

## 4 图

### 4.1 图的定义与存储

### 4.2 图的遍历

### 4.3 生成树及最小生成树

### 4.4 拓扑排序和关键路径

### 4.5 最短路径

### 5 查找

### 5.1 查找的基本概念

### 5.2 静态查找表的查找方法

### 5.3 动态查找表

### 5.4 哈希表

## 6 排序

### 6.1 排序的基本概念

### 6.2 简单排序

### 6.3 希尔排序

### 6.4 快速排序

### 6.5 堆排序

### 6.6 归并排序

### 6.7 基数排序

### 6.8 内部排序方法小结

### 6.9 外部排序

## 7 加餐和总结
