---
title: 三、数据结构
date: 2025-05-05 16:55:00
updated: 2025-05-05 16:55:00
categories: [软件设计师]
---

## 1 线性结构

- 数据结构是程序设计的重要基础，它讨论数据元素集合及其相互关系和构造方法。
- 数据结构分为线性结构和非线性结构，非线性结构包括树结构和图结构。
- 算法设计依赖数据结构，合理数据结构可提升算法效率。

### 1.1 线性表

#### 1.1.1 线性表的定义

- 线性表是 $n(n \geq 0)$ 个元素的有限序列，通常表示为 $(a_1, a_2, \cdots, a_n)$。<!-- more -->
- 非空线性表的特点：
    - 存在唯一的“第一个”元素。
    - 存在唯一的“最后一个”元素。
    - 除第一个元素外，每个元素只有一个直接前驱。
    - 除最后一个元素外，每个元素只有一个直接后继。

#### 1.1.2 线性表的存储结构

##### 1.1.2.1 线性表的存储结构

## 1. 顺序存储

- **定义**：用一组连续存储单元依次存储线性表元素，逻辑相邻则物理相邻。
- **优点**：可随机访问元素。
- **缺点**：插入和删除需移动元素。
- **插入操作**：平均需移动 $\frac{n}{2}$ 个元素。
- **删除操作**：平均需移动 $\frac{n-1}{2}$ 个元素。

##### 1.1.2.2 链式存储

- **定义**：用指针链接结点存储数据元素。
- **基本结构**：每个结点包含数据域和指针域。
- **单链表**：
    - **插入操作**：修改指针。
    - **删除操作**：修改指针并释放空间。
- **查找操作**：从头指针开始顺序查找。
- **插入操作**：在指定位置插入新结点。
- **删除操作**：删除指定位置的结点。
- **优点**：插入和删除无需移动元素。

**变种链表结构**

- **双向链表**：每个结点包含两个指针，分别指向前驱和后继。
- **循环链表**：尾结点指针指向头结点。
- **静态链表**：用数组模拟链表结构。

### 1.2 栈和队列

#### 1.2.1 栈

- **定义**：后进先出（LIFO）的线性表，一端为栈顶，另一端为栈底。
- **基本运算**：
    - 初始化栈 `InitStack(S)`。
    - 判空 `isEmpty(S)`。
    - 入栈 `Push(S, x)`。
    - 出栈 `Pop(S)`。
    - 读取栈顶元素 `Top(S)`。
- **存储结构**：
    - **顺序存储**：用连续存储单元，附设指针 `top`。
    - **链式存储**：用链表，头指针为栈顶指针。
- **应用**：表达式求值、括号匹配、递归处理。

#### 1.2.2 队列

队列是一种先进先出（FIFO）的线性表，元素从队尾插入，从队头删除。其基本运算包括：

- 初始化队列 `InitQueue(Q)`。
- 判空 `isEmpty(Q)`。
- 入队 `EnQueue(Q, x)`。
- 出队 `DelQueue(Q)`。
- 读取队头元素 `FrontQue(Q)`。

**顺序存储**

顺序队列利用连续存储单元存放元素，设置队头指针 `front` 和队尾指针 `rear`。为提高空间利用率，常将顺序队列设计为循环队列。
- 入队操作：`rear = (rear + 1) % MAXSIZE`。
- 出队操作：`front = (front + 1) % MAXSIZE`。
- 特殊情况处理：需区分队空（`front == rear`）和队满（`(rear + 1) % MAXSIZE == front`）。

* **链式存储**：链队列（队列的链式存储）包含头指针和尾指针，便于操作。队空时头指针和尾指针均指头结点。
* **队列的应用**：队列适用于需要排队的场景，如操作系统中的打印任务队列、事件模拟等。

### 1.3 串

#### 1.3.1 串的定义及基本运算

串是字符构成的有限序列，记作 $S = 'a_1a_2 \cdots a_n'$，其中 $S$ 是串名，单引号内是串值。

**基本概念**

- **空串**：长度为 0 的串。
- **空格串**：由一个或多个空格组成的串。
- **子串**：串中任意连续字符的序列，所在位置是首次出现时的第一个字符位置。
- **串相等**：两串长度相等且对应字符相同。
- **串比较**：比较两串大小时，逐字符比较 ASCII 值，较短的串较小。

**基本操作**

- 赋值操作 `StrAssign(s, t)`。
- 连接操作 `Concat(s, t)`。
- 求串长 `StrLength(s)`。
- 串比较 `StrCompare(s, t)`。
- 取子串 `SubString(s, start, len)`。

#### 1.3.2 串的存储结构

* 顺序存储：用连续存储单元存储字符序列，可通过字符数组或动态申请空间实现。
* 链式存储：用链表存储字符，结点可存储一个或多个字符，需考虑存储密度。

#### 1.3.3 串的模式匹配

模式匹配是查找子串（模式串）在主串中的位置，是串处理的重要运算。

##### 1.3.3.1 朴素的模式匹配算法

- **基本思想**：从主串第一个字符开始逐个比较，不匹配则主串指针回退。
- **时间复杂度**：
    - 最好情况：$O(n + m)$。
    - 最坏情况：$O(n \times m)$。

##### 1.3.3.2 改进的 KMP 算法

- **核心思想**：不回退主串指针，利用部分匹配信息移动模式串。
- **关键**：构造 `next` 数组，记录模式串的部分匹配长度。
- **时间复杂度**：$O(n + m)$。

## 2 数组、矩阵和广义表

### 2.1 数组

### 2.2 矩阵

### 2.3 广义表

## 3 树

### 3.1 树与二叉树的定义

### 3.2 二叉树的性质与存储结构

### 3.3 二叉树的遍历

### 3.4 线索二叉树

### 3.5 最优二叉树

### 3.6 树和森林

## 4 图

### 4.1 图的定义与存储

### 4.2 图的遍历

### 4.3 生成树及最小生成树

### 4.4 拓扑排序和关键路径

### 4.5 最短路径

### 5 查找

### 5.1 查找的基本概念

### 5.2 静态查找表的查找方法

### 5.3 动态查找表

### 5.4 哈希表

## 6 排序

### 6.1 排序的基本概念

### 6.2 简单排序

### 6.3 希尔排序

### 6.4 快速排序

### 6.5 堆排序

### 6.6 归并排序

### 6.7 基数排序

### 6.8 内部排序方法小结

### 6.9 外部排序

## 7 加餐和总结
