---
title: linux 教程 02 文件系统
date: 2019-03-17 17:27:17
updated: 2022-11-05 13:45:00
categories: linux
---

Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。

## FHS 标准

Linux 的目录结构说复杂很复杂，说简单也很简单。复杂在于，因为系统的正常运行是以目录结构为基础的，对于初学者来说里面大部分目录都不知道其作用，重要与否，特别对于那些曾经的重度 Windows 用户，他们会纠结很长时间，关于我安装的软件在哪里这类问题。说它简单是因为，其中大部分目录结构是规定好了的（FHS 标准），是死的，当你掌握后，你在里面的一切操作都会变得井然有序。

FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。

> FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等。
> 第二层则是针对 /var 及 /usr 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等等。

![](https://upload-images.jianshu.io/upload_images/1662509-a370c69fb1e8909d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

关于上面提到的 FHS，这里还有个很重要的内容你一定要明白，FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会维持更新，FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示：

![](https://upload-images.jianshu.io/upload_images/1662509-a084bf9f01cae3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<!-- more -->

## 目录路径

```sh
$ cd ~
# 或者 cd /home/<你的用户名>
```

使用 pwd 获取当前路径：

* 绝对路径：简单地说就是以根 "/" 目录为起点的完整路径，以你所要到的目录为终点
* 相对路径：相对于你当前的目录的路径，相对路径是以当前目录 . 为起点

## Linux 文件的基本操作

新建、复制、删除、移动文件与文件重命名、查看文件、查看文件类型、以及编辑文件。

touch 文件, 若存在则更新时间戳

mdkir 创建文件夹
mkdir 使用 -p 参数，同时创建父目录（如果不存在该父目录）

### 复制文件

使用 cp 命令（copy）复制一个文件到指定目录。

copy 文件夹至对应目录 `cp -r`

**删除文件**
rm xxx
rm -f xxx 强制删除, 对于解决想要删除一些为只读权限的文件，直接使用 rm 删除会显示一个提示的问题

删除目录就是 rm -r 表示递归删除, 如果是强制删除则是 rm -rf

## 查看文件

cat 为正序显示，tac 为倒序显示。可以加上 -n 参数显示行号

nl 命令，添加行号并打印，这是个比 cat -n 更专业的行号打印命令。

这里简单列举它的常用的几个参数：

```sh
-b : 指定添加行号的方式，主要有两种：
    -b a: 表示无论是否为空行，同样列出行号("cat -n"就是这种方式)
    -b t: 只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln: 在行号字段最左端显示
    -n rn: 在行号字段最右边显示，且不加 0
    -n rz: 在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)
```

**使用 more 和 less 命令分页查看文件**
那么这个 more 和 less 就是天生用来"阅读"一个文件的内容的，比如说 man 手册内部就是使用的 less 来显示内容。

其中 more 命令比较简单，只能向一个方向滚动

打开后默认只显示一屏内容，终端底部显示当前阅读的进度。
可以使用 Enter 键向下滚动一行，使用 Space 键向下滚动一屏，按下 h 显示帮助，q 退出

而 less 为基于 more 和 vi （一个强大的编辑器，我们有单独的课程来让你学习）开发，功能更强大。less 的使用基本和 more 一致，具体使用请查看 man 手册，这里只介绍 more 命令的使用。

使用 head 和 tail 命令查看文件

甚至更直接的只看一行， 加上 -n 参数，后面紧跟行数：

```sh
tail -n 1 /etc/passwd
```

关于 tail 命令，不得不提的还有它一个很牛的参数 -f，这个参数可以实现不停地读取某个文件的内容并显示。

### 查看文件类型

我们可以使用 file 命令查看文件的类型：

与 Windows 不同的是，如果你新建了一个 shiyanlou.txt 文件，Windows 会自动把它识别为文本文件，而 file 命令会识别为一个空文件。这个前面我提到过，在 Linux 中文件的类型不是根据文件后缀来判断的。当你在文件里输入内容后才会显示文件类型。

**编辑文件**
vim 的使用
如果你想更加快速地入门，可以直接使用 Linux 内部的 vim 学习教程，输入如下命令即可开始：

```sh
vimtutor
```

## 搜索文件

与搜索相关的命令常用的有 whereis，which，find 和 locate。

whereis 简单快速
whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。

which 小而精
which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的程序，因为它只从 PATH 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。

find 精而细
find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。find 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。

这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式

```sh
find /etc/ -name interfaces
```

列出用户家目录下比 /etc 目录新的文件：

```sh
find ~ -newer /etc
```

使用 df 命令查看磁盘的容量

```sh
df
```

使用 du 命令查看目录的容量

```sh
# 默认同样以 块 的大小展示
du
# 加上`-h`参数，以更易读的方式展示
du -h
# 查看层级为 1，这样运行速度快
du -h --max-depth=1
```

-d 参数指定查看目录的深度

```sh
du -h #同--human-readable 以 K，M，G为单位，提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计，只列出最后加总的值。

来自: http://man.linuxde.net/du
```

## 简单的磁盘管理

dd 命令用于转换和复制文件，不过它的复制不同于 cp。

dd 的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的--选项 值或-选项=值。dd 默认从标准输入中读取，并写入到标准输出中，但可以用选项 if（input file，输入文件）和 of（output file，输出文件）改变。

```sh
# 输出到文件
dd if=/dev/stdin of=test bs=10 count=1
# 或者省略 if=/dev/stdin 也是可以的

# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1
# 注在打完了这个命令后，继续在终端打字，作为你的输入
```

使用 dd 命令创建虚拟镜像文件
从/dev/zero 设备创建一个容量为 256M 的空文件：

```sh
dd if=/dev/zero of=virtual.img bs=1M count=256
du -h virtual.img
```

使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）
我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为 ext4 文件系统：

```sh
sudo mkfs.ext4 virtual.img
```

**使用 mount 命令挂载磁盘到目录树**
用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。

Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。

我们先来使用 mount 来查看下主机已经挂载的文件系统：

```sh
sudo mount
```

那么我们如何挂载真正的磁盘到目录树呢，mount 命令的一般格式如下：

```sh
mount [options] [source] [directory]
```

一些常用操作

```sh
mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
```

```sh
mount -o loop -t ext4 virtual.img /mnt
# 也可以省略挂载类型，很多时候 mount 会自动识别

# 以只读方式挂载
mount -o loop --ro virtual.img /mnt
# 或者mount -o loop,ro virtual.img /mnt
```

使用 umount 命令卸载已挂载磁盘

```sh
# 命令格式 sudo umount 已挂载设备名或者挂载点，如：
sudo umount /mnt
```

**使用 fdisk 为磁盘分区（关于分区的一些概念不清楚的用户请参看[主引导记录](http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95)）**

```sh
# 查看硬盘分区表信息
sudo fdisk -l

# 进入磁盘分区模式
sudo fdisk virtual.img
```

找出当前目录下面占用最大的前十个文件。

```sh
du -ah -d 1 | sort -hr | head -n 10
```

解释：-a 是所有文件，-h 是可读方式，-d 是深度，1 代表 2 层，也就保证了作业要求恶的当下目录中，sort 是排序，-r 是倒着排，-h 和之前的一样，head 是取头部，-n 是取的数量，10 是是个文件。

## 磁盘分区

/boot/efi 格式化为 fat32 分区 一般 250MB 就够了
/ 格式化为 ext4 分区

## 参考

[Linux 基础入门（新版）\_Linux - 实验楼](https://www.shiyanlou.com/courses/1)
