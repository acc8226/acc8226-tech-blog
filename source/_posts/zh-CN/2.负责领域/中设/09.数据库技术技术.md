---
title: 九、数据库技术基础
date: 2025-05-14 17:47:47
updated:  2025-05-14 17:47:47
categories: [软件设计师]
---

## 1 基本概念

### 1.1 数据库与信息系统

**数据库**是长期存储在计算机内的、有组织的、可共享的数据集合。数据库系统(DBS)由数据库(DB)、硬件、软件和相关人员组成。其中，数据库管理系统(DBMS)是核心软件，负责数据的组织、存储和管理。

### 1.2 数据库管理系统的功能

数据库管理系统简称 DBMS，它是数据库系统的核心软件，需要在操作系统的支持下工作。DBMS 的主要功能包括：

1. 数据定义：提供 DDL，用于定义数据库的结构和模式。
1. 数据库操作：提供 DML，支持数据的增删改查。
1. 数据库运行管理
1. 数据的组织、存储与管理：负责数据的存储结构和存取方法。<!-- more -->
1. 数据库的建立和维护：包括数据库的初始建立、转储、恢复等。
1. 其他功能：如网络通信、数据转换和互操作等。

### 1.3 DBMS 的特征与分类

DBMS 具有以下特点：

1. 数据结构化和统一管理：数据由 DBMS 统一管理，减少数据冗余。
2. 数据独立性：数据与程序分离，提高数据的共享性和可维护性。
3. 数据的安全性和完整性：提供安全性和完整性机制，保护数据。
4. 并发控制和故障恢复：支持多用户并发操作，并能恢复数据一致性。

DBMS 的分类：

1. 关系型数据库管理系统（RDBS）：基于关系模型，如 Oracle、MySQL 等。
2. 面向对象数据库管理系统（OODBS）：支持对象模型，提供继承和封装特性。
3. 对象关系数据库管理系统（ORDBS）：结合关系模型和对象模型。

### 1.4 数据库系统的体系结构

数据库系统是数据密集型应用的核心，其体系结构受数据库运行所在的计算机系统的影响
很大，尤其是受计算机体系结构中的连网、并行和分布的影响。从最终用户的角度看，数据库系统体系结构分为集中式、分布式、C/S（客户端/服务器）和并行结构。

#### 1.4.1 集中式数据库系统

所有功能集中在一台计算机上，适合小型企业或部门。

#### 1.4.2 客户端/服务器结构（C/S）

分为前端客户机和后端服务器：

- 客户机：负责数据表示和用户交互。
- 服务器：负责数据存储和管理。

#### 1.4.3 并行数据库系统

多个 CPU 协同工作，提高数据处理效率：

- 共享内存多处理器体系结构：多个 CPU 共享内存和磁盘。
- 无共享并行体系结构：每个 CPU 有独立的内存和磁盘，通过高速网络连接。

#### 1.4.4 分布式数据库系统

分布式 DBMS 包括物理上分布、逻辑上集中的分布式数据库结构和物理上分布、逻辑上
分布的分布式数据库结构两种。

### 1.5 数据库的三级模式结构

数据库系统采用三级模式结构，包括外模式、概念模式和内模式。

#### 1.5.1 三级模式

##### 1.5.1.1 外模式

**外模式**也称**用户模式**或**子模式**，是用户与数据库系统的接口，描述了用户用到的那部分数据的结构。它定义了若干个外模式，用户通过外模式对数据库进行操作，程序员无需关心概念模式和内模式。

描述外模式的数据定义语言称为“外模式 DDL”。

##### 1.5.1.2 概念模式

**概念模式**也称**模式**，是数据库中全部数据的逻辑结构和特征的描述。它描述了数据库的结构和联系，不涉及具体的值。概念模式的一个具体值称为模式的一个实例，同一概念模式可以有多个实例。它相对稳定，不随实例的变化而变化。

描述概念模式的数据定义语言称为“模式 DDL”。

##### 1.5.1.3 内模式

**内模式**也称**存储模式**，是数据物理结构和存储方式的描述，定义了数据的存储结构、存取路径等细节。内模式更接近于数据的物理存储。

描述内模式的数据定义语言称为“内模式 DDL”。

#### 1.5.2 两级映像

数据库系统在三级模式之间提供了两级映像，以保证数据的独立性：

1. 模式/内模式映像：存在于概念级和内部级之间，实现了概念模式和内模式之间的相互转换。
2. 外模式/模式映像：存在于外模式和概念模式之间，实现了外模式和概念模式之间的相互转换。

数据的独立性包括数据的物理独立性和数据的逻辑独立性。

1. 数据的物理独立性。数据的物理独立性是指当数据库的内模式发生改变时，数据的逻辑结构不变。
2. 数据的逻辑独立性。数据的逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。

### 1.6 大数据

#### 1.6.1 大数据的背景

大数据是“无法用现有的软件工具提取、存取、搜索、共享、分析和处理的海量的、复杂的数据集合”。其产生的背景主要包括数据来源和存取方式的变革、数据量爆炸式增长、数据已经成为一种重要资源、数据变得日益重要等。

#### 1.6.2 大数据的特征

业界常用“4V”来概括大数据的特征：

- Volume（体量）：数据量极大，从TB到PB、ZB级别。
- Variety（种类）：数据类型多样，包括结构化、半结构化和非结构化数据。
- Value（价值密度低）：有价值的信息占比低，需要通过算法提取。
- Velocity（速度）：数据增长和处理速度快，需要快速存储和分析。

#### 1.6.3 理解大数据

1. 数据存储的扩展能力：提升存储和管理能力，支持结构化和非结构化数据。
2. 数据资源的普适化：解决数据共享和普惠化问题，特别是非结构化数据的处理。
3. 智能处理海量信息：解决自然语言理解、多媒体内容理解等问题。

#### 1.6.4 大数据的安全风险

1. **数据成为网络攻击目标**：大数据集中存储吸引黑客攻击，增加安全风险。
2. **数据泄露和隐私风险**：大量数据集中存储加大隐私泄露风险，许多数据未明确所有权和使用权。
3. **法律法规滞后**：现有法律未能完全涵盖大数据存储和使用，导致隐私问题。
4. **数据成为网络武器**：大数据被用于攻击商业和国家信息基础设施。
5. **大数据提高网络攻击效率**：攻击者利用大数据提高攻击效率和精准度。
6. **大数据为信息安全带来新机遇**：大数据提供分析网络风险的能力，助力识别和防止网络攻击。

## 2 数据模型

### 2.1 基本概念

数据模型是对现实世界数据特征的抽象，分为两类：

1. **概念数据模型**：从用户角度对数据建模，强调语义表达，易于理解，主要用于数据库设计。典型代表是 **E-R 模型**。
2. **基本数据模型**：从计算机系统角度对数据建模，用于 DBMS 的实现。包括层次模型、网状模型、关系模型和面向对象模型。

### 2.2 数据模型的三要素

数据模型由以下三要素构成：

1. 数据结构：描述对象类型的集合，体现系统的静态特性。
2. 数据操作：定义对数据库对象允许执行的操作及其规则，体现系统的动态特性。
3. 数据的约束条件：定义数据必须遵循的完整性规则，确保数据的正确性和一致性。

### 2.3 E-R 模型

E-R 模型（实体 - 联系模型）是一种常用的概念数据模型，用于描述现实世界的对象及其相互关系。它由 P. P. S. Chen 于 1976 年提出，具有易于理解和使用的优点。

#### 2.3.1 实体

* 定义：实体是现实世界中可以区分的“事件”或“物体”。
* 表示：用矩形框表示，框内写明实体名。
* 属性：实体由一组特性（属性）组成，每个属性有其取值范围。

#### 2.3.2 联系

* 定义：联系表示实体之间的关系。
* 表示：用菱形框表示，框内写明联系名，并用无向边连接相关实体。
* 类型：
  * 1:1 联系：一个实体集中的一个实体最多与另一个实体集中的一个实体相联系。比如电影院一个座位只能坐一个观众。
  * 1:n 联系：一个实体集中的一个实体可与另一个实体集中的多个实体相联系。比如一位教师可以任课多门课程。
  * m:n 联系：两个实体集中的多个实体可相互联系。比如学生可以选修多门课程，一门课程也可以被多个学生选修。

#### 2.3.3 属性

* 定义：属性是实体某方面的特性。
* 类型：
  * 简单属性和复合属性。
  * 单值属性和多值属性。
  * NULL 属性。
  * 派生属性。

#### 2.3.4 实体-联系方法

概念模型中最常用的方法为实体-联系方法，简称 E-R 方法。用 E-R 图来表示数据模型。

#### 2.3.5 扩展 E-R 模型

**弱实体**
  * 定义：弱实体的存在必须以另一个实体为前提。
  * 表示：用双线矩形框表示。
**特殊化**
  * 定义：将一个一般实体集划分为若干个特殊实体集。
  * 表示：用特殊化树表示，连线为单线表示部分特殊化，双线表示全部特殊化。

#### 2.3.6 应用实例

以学校教学管理系统为例，E-R 模型包括以下实体和联系：

* 实体：系、教师、学生、项目、课程。
* 联系：
  * 系与教师之间的 1:n“任职”联系。
  * 教师与项目之间的 m:n“参加”联系。
  * 学生与课程之间的 m:n“选修”联系。
  * 教师、学生与系之间的 1:n:m“领导”联系。

通过 E-R 模型，可以清晰地描述学校教学管理系统中的各类对象及其相互关系，为数据库设计提供直观的基础。

## 2 数据库技术基础

### 2.4 数据模型

* 层次模型：像一棵倒立的树，根结点只有一个，其他结点只能有一个父结点。
* 网状模型：比层次模型更自由，允许多个父结点和复杂关系。
* 关系模型：用表格形式表示数据，直观且易于理解。
* 面向对象模型：以对象为核心，包含属性和方法，但较为复杂。

### 2.5 关系模型

关系模型（Relational Model）是目前最常用的数据模型之一。关系数据库系统采用关系模型作为数据的组织方式，在关系模型中用表格结构表达实体集以及实体集之间的联系，其最大特色是描述的一致性。

关系模式：相当于表格的结构定义，包含属性（列）。
关系实例：实际的数据表格，随时间可变。
主属性：用下划线标识，是表中的关键属性。

示例：教学数据库的 4 个关系模式

* 学生 S 关系模式：S(Sno,Sname,SD,Age,Sex)，属性为学号、姓名、系、年龄和性别。
* 教师 T 关系模式：T(Tno,Tname,IS,Age,Sex)，属性为教师号、姓名、年龄和性别。
* 课程 C 关系模式：C(Cno,Cname,Pcno)，属性为课程号、课程名和先修课程号。
* 学生选课 SC 关系模式：SC(Sno,Cno,Grade)，属性为学号、课程号和成绩。

下图是关系模型的一个实例，展示了学生、教师、选课和课程的关系模式表：

表：学生 S 关系

| Sno    | Sname  | SD  | Age | Sex |
|--------|--------|-----|-----|-----|
| 01001  | 贾晓明 | IS  | 20  | 男  |
| 01002  | 姚勇   | IS  | 20  | 男  |
| 03001  | 李晓红 | CS  | 19  | 女  |

表：教师 T 关系

| Tno | Tname | IS  | Age | Sex |
|-----|-------|-----|-----|-----|
| 001 | 方楠  | 34  | 女  |
| 002 | 蒋本敏| 58  | 男  |
| 003 | 王平  | 48  | 女  |

表：SC 选课

| Sno    | Cno   | Grade |
|--------|-------|-------|
| 01001  | C001  | 90    |
| 01001  | C002  | 91    |
| 01002  | C001  | 95    |

表：C 课程关系

| Cno    | Cname   | Pcno   |
|--------|---------|--------|
| C001   | MS | |
| C002   | IC | |
| C003   | C++     | C002   |

## 3 关系代数

### 3.1 关系数据库的基本概念

#### 3.1.1 属性和域

* 属性（Attribute）：描述事物的特征，如学生的学号、姓名等。
* 域（Domain）：属性的取值范围，如学号是 6 位整型数字，姓名是 10 位字符。
* 关系模型限制：通常要求属性为原子数据（Atomic Data），即第一范式（1NF）。关系模型突破此限制的称为非 1NF 的关系数据模型。

#### 3.1.2 笛卡尔积与关系

* **笛卡尔积（Cartesian Product）**：定义为 $D_1 \times D_2 \times \cdots \times D_n = \{ (d_1, d_2, \cdots, d_n) | d_i \in D_i, i = 1, 2, \cdots, n \}$，其中每个元素 $(d_1, d_2, \cdots, d_n)$ 称为 $n$ 元组，每个值 $d_i$ 称为元组的一个分量。若 $D_i (i = 1, 2, \cdots, n)$ 为有限集，基数为 $m_i$，则笛卡尔积的基数 $M = \prod_{i=1}^n m_i$。
  * **示例**：若 $D_1 = \{ 0, 1 \}$，$D_2 = \{ a, b \}$，$D_3 = \{ c, d \}$，则 $D_1 \times D_2 \times D_3 = \{ (0, a, c), (0, a, d), (0, b, c), (0, b, d), (1, a, c), (1, a, d), (1, b, c), (1, b, d) \}$。
* **关系（Relation）**：在域 $D_1, D_2, \cdots, D_n$ 上的子集称为在域 $D_1, D_2, \cdots, D_n$ 上的关系，记为 $R(D_1, D_2, \cdots, D_n)$。关系中的元组个数称为 “基数”，元组的分量个数称为 “目” 或 “度”。

#### 3.1.3 关系的有关名词

* 目或度（Degree）：关系中属性的个数，记为 $n$。
* 候选码（Candidate Key）：若关系中的某单一属性或属性组的值**能唯一标识一个元组**，则称该属性或属性组为候选码。若有多码，需选定一个作为主码。
* 主属性（Prime Attribute）：包含在任何一个候选码中的属性。
* 非主属性（Non-Prime Attribute）：不包含在任何候选码中的属性。
* 外码（Foreign Key）：若关系模式 $S$ 中的属性或属性组非 $S$ 的码，但是另一个关系模式的码，则为 $S$ 的外码。
* 全码（All-Key）：当且仅当关系模式的所有属性组成为候选码时，称全码。

#### 3.1.4 关系的 3 种类型

* 基本关系（基表、基表或基本表）：实际存在的表，是实际存储数据的逻辑表示。
* 查询表：查询结果对应的表。
* 视图表：由基本表或其他视图表导出的表，自身不独立存储在数据库中。由于本身不独立存储在数据库中，只存放定义，所以常称为虚表。

#### 3.1.5 关系数据库模式

* 关系数据库模式：是关系数据库结构的描述，由若干个关系模式构成。形式化表示为 $R(U, D, dom, F)$，其中 $R$ 表示关系名；$U$ 是组成该关系的属性名集合；$D$ 是域的集合；$dom$ 是属性向域的映像集合；$F$ 为属性间数据的依赖关系集合。通常简记为 $R(U)$ 或 $R(A_1, A_2, \cdots, A_n)$。

#### 3.1.6 完整性约束

* 实体完整性（Entity Integrity）：规定基本关系 $R$ 的主属性不能取空值。
* 参照完整性（Referential Integrity）：若 $F$ 是基本关系 $S$ 的外码，它与基本关系 $R$ 的主码 $K_R$ 相关，则对于 $S$ 中每个元组在 $F$ 上的值必须为空，或等于 $R$ 中某个元组的 $K_R$ 值。例如，员工关系中的 “部门号” 属性是外码，其取值要参照部门关系的 “部门号” 属性。
* 用户定义完整性（User Defined Integrity）：针对某一具体关系数据库的语义约束，如银行的用户账户规定必须大于等于 0.01、小于 1000000。

#### 3.1.7 关系运算

* 关系运算特点：操作对象和操作结果均是集合，关系数据语言分为三类：关系代数语言、关系演算语言和具有关系代数和关系演算双重特点的语言（如 SQL）。
* 关系代数运算符：分为集合运算符和专门的关系运算符。专门的关系运算符包括选择、投影、连接和除运算。传统的集合运算是从关系的水平方向进行，包括并、交、差及广义笛卡尔积；专门的关系运算符可从关系的垂直方向进行操作，包括选择、投影、连接和除运算。

表：关系代数运算符：

| 运算符 | 含义 | 运算符 | 含义 |
|--------|--------------|--------|---------|
| $\cup$ | 并 | $>$ | 大于 |
| $-$ | 差 | $>=$ | 大于等于 |
| $\cap$ | 交 | $<$ | 小于 |
| $\times$ | 笛卡尔积 | $<=$   | 小于等于 |
| $\sigma$ | 选择 | $=$ | 等于 |
| $\pi$ | 投影 | $\neq$ | 不等于 |
| $\bowtie$ | 连接 | $\neg$ | 非 |
| $\div$ | 除 | $\wedge$ | 与 |
| | | $\vee$ | 或 |

### 3.2 五种基本的关系代数运算

包括并、差、广义笛卡尔积、投影和选择，其他运算可以通过这些基本运算组合而成。

#### 3.2.1  并（Union）

* 定义：关系 $R$ 与 $S$ 具有相同的关系模式，即 R 与 S 的元数相同（结构相同）。关系 R 与 S 的并是由属于 R 或属于 S 的元组构成的集合，记作 R ∪ S。
* 形式定义：$R \cup S = \{ t \mid t \in R \lor t \in S \}$，其中 t 为元组变量。

#### 3.2.2 差（Difference）

* 定义：关系 $R$ 与 $S$ 具有相同的关系模式，关系 $R$ 与 $S$ 的差是由属于 R 但不属于 $S$ 的元组构成的集合，记作 R − S。
* 形式定义：$R - S = \{ t \mid t \in R \land t \notin S \}$。

#### 3.2.3 广义笛卡尔积（Extended Cartesian Product）

* 定义：两个元数分别为 n 和 m 目的关系 R 和 S 的广义笛卡尔积是一个 (n + m) 列的元组的集合。元组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S。

#### 3.2.4 投影（Projection）

* 定义：投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 π_A(R)。
* 形式定义：$\pi_A(R) = \{ [A] \mid t \in R \}$。

#### 3.2.5 选择（Selection）

* 定义：选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的诸元组，记作 σ_F(R)。
* 形式定义：$\sigma_F(R) = \{ t \mid t \in R \land F(t) = \text{True} \}$，其中 F 中的运算对象是属性名（或列的序号）或常数，运算符包括比较符（如 <, ≤, >, ≥, ≠）和逻辑运算符（如 ∧, ∨, ¬）。

#### 3.2.6 示例：关系运算的应用

设存在关系 R 和 S，那么

1. R ∪ S：合并 R 和 S 中的所有元组，去除重复项。
2. R − S：选取 R 中有但 S 中没有的元组。
3. R × S：生成 R 和 S 的广义笛卡尔积。
4. $π_{A,C}(R)$：对 R 进行投影，选取 A 和 C 列。
5. $σ_{1 > 3}(R)$：选取 R 中 第 1 个属性值大于 第 3 个属性值的元组。

### 3.3 扩展的关系代数运算

#### 3.3.1 交（Intersection）

* 定义：关系 $R$ 与 $S$ 的交是由属于 $R$ 同时又属于 $S$ 的元组构成的集合，记作 $R \cap S$。
* 形式定义：$R \cap S = \{ t \mid t \in R \land t \in S \}$。
* 性质：显然，$R \cap S = R - (R - S)$ 或 $R \cap S = S - (S - R)$。

#### 3.3.2 连接（Join）

连接运算是从两个关系 $R$ 和 $S$ 的笛卡尔积中选取满足条件的元组。

##### 3.3.2.1 θ 连接

* **定义**：从 $R$ 与 $S$ 的笛卡尔积中选取属性间满足一定条件的元组，记作 $R \bowtie_{X \theta Y} S$，其中 $\theta$ 是比较运算符，$X$ 和 $Y$ 是分别来自 $R$ 和 $S$ 上的属性。

##### 3.3.2.2 等值连接

* 定义：当 $\theta$ 为 “$=$” 时，称为等值连接，记作 $R \bowtie_{X=Y} S$。

##### 3.3.2.3 自然连接

* 定义：**自然连接是一种特殊的等值连接**，要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性组列去掉。
* 性质：自然连接 $R \bowtie S$可以由基本的关系代数运算导出。

##### 3.3.2.3 除（Division）

* 定义：除运算是同时从关系的水平方向和垂直方向进行运算。给定关系 $R(X, Y)$ 和 $S(Y, Z)$，$X$、$Y$、$Z$ 为属性组。$R \div S$ 应当满足元组在 $X$ 上的分量值 $x$ 的象集 $Y_x$ 包含关系 $S$ 在 $Y$ 上投影的集合。
* 性质：除法运算可以由基本的关系代数运算导出。

除法运算的核心是 找到在某个属性组（如学号 Sno 或供应商号 Sno）上，其对应的另一个属性组（如课程号 Cno 或零件号 Pno）的值包含第二个关系中所有对应值的元组。通过投影和筛选，我们可以得到满足条件的结果。

##### 3.3.2.4 广义投影（Generalized Projection）

广义投影运算允许在投影列表中使用算术运算。

##### 3.3.2.5 外连接（Outer Join）

外连接运算是连接运算的扩展，用于处理因连接运算而丢失的信息。分为左外连接、右外连接和全外连接。

 1. 左外连接（Left Outer Join）$\bowtie^\text{左}$
  * 定义：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。
2. 右外连接（Right Outer Join）$\bowtie^\text{右}$
  * 定义**：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。
3. 全外连接（Full Outer Join）$\bowtie^\text{全}$
  * 定义：完成左外连接和右外连接的操作，即填充左侧关系和右侧关系中所有不匹配的元组，将产生的新元组加入自然连接的结果中。

## 4 关系数据库 SQL 语言简介

### 4.1 SQL 数据库体系结构

#### 4.1.1 SQL 的特点

SQL（Structured Query Language）的特点如下：

1. 综合统一
2. 高度度非过程化
3. 面向集合的操作方式
4. 两种使用方式：可以终端输入（自含式语言）和嵌入到高级语言程序中（嵌入式语言）。
5. 语言简洁、易学易用

SQL 语言功能强大，核心功能仅用 9 个动词实现，包括以下 4 类：

- 数据查询：`SELECT`
- 数据定义：`CREATE`、`DROP`、`ALTER`
- 数据操纵：`INSERT`、`UPDATE`、`DELETE`
- 数据控制：`GRANT`、`REVOKE`

#### 4.1.2 SQL 支持三级模式结构

- 视图：对外模式
- 基本表：对模式
- 存储文件：对内模式

### 4.2 SQL 的基本组成

1. 数据定义语言（SQL DDL）：提供定义关系模式和视图、删除关系和视图、修改关系模式的命令。
2. 交互式数据操纵语言（SQL DML）：提供查询、插入、删除和修改的命令。
3. 事务控制（Transaction Control）：提供定义事务开始和结束的命令。
4. 嵌入式 SQL 和动态 SQL：用于嵌入到高级语言中混合编程
5. 完整性（Integrity）：确保数据库中的数据满足完整性约束条件，禁止破坏完整性的更新。
6. 权限管理（Authorization）：管理对关系和视图的访问权限。

### 4.3 SQL 数据定义

#### 4.3.1 创建表 (CREATE TABLE)

用于定义表的结构，包括列名、数据类型和完整性约束条件。

```sql
CREATE TABLE 表名 (
    列名1 数据类型 [完整性约束条件],
    列名2 数据类型 [完整性约束条件],
    ...
);
```

示例：创建供应商表 S

```sql
CREATE TABLE S (
    Sno CHAR(5) NOT NULL UNIQUE,
    Sname CHAR(30) NOT NULL UNIQUE,
    Status CHAR(8),
    City CHAR(20),
    PRIMARY KEY(Sno)
);
```

#### 4.3.2 修改表 (ALTER TABLE)

用于修改表的结构，如添加或删除列。

```sql
ALTER TABLE 表名 ADD 列名 数据类型 [完整性约束条件];
ALTER TABLE 表名 DROP COLUMN 列名;
```

示例：向供应商表 S 添加新列

```sql
ALTER TABLE S ADD Zip CHAR(6);
```

#### 4.3.3 删除表 (DROP TABLE)

用于删除表及其数据。

```sql
DROP TABLE 表名;
```

#### 4.3.4 索引建立与删除

索引用于提高数据检索效率。

#### 4.3.5 创建索引

```sql
CREATE [UNIQUE] INDEX 索引名 ON 表名 (列名 [ASC|DESC]);
```

示例：为供应商表 S 的 Sno 列创建唯一索引

```sql
CREATE UNIQUE INDEX idx_S_Sno ON S(Sno);
```

#### 4.3.6 删除索引

```sql
DROP INDEX 索引名;
```

#### 4.3.7 视图创建与删除

视图是从一个或多个基本表或视图中导出的表，用于简化查询和保护数据。

#### 4.3.8 创建视图

```sql
CREATE VIEW 视图名 (列名) AS SELECT 查询语句 [WITH CHECK OPTION];
```

示例：创建计算机系学生的视图

```sql
CREATE VIEW CS_STUDENT (Sno, Sname, Sex) AS
SELECT Sno, Sname, Sex
FROM Student
WHERE SD = 'CS'
WITH CHECK OPTION;
```

#### 4.3.9 删除视图

```sql
DROP VIEW 视图名;
```

## 4.4 SQL 数据查询

### 4.4.1 SELECT 基本结构

SQL 查询语句的基本结构包括以下几个子句：

```sql
SELECT [ALL | DISTINCT] <目标列表表达式>
FROM <表名或视图名>
[WHERE <条件表达式>]
[GROUP BY <列名>]
[HAVING <条件表达式>]
[ORDER BY <列名> [ASC | DESC]]
```

其中，`SELECT` 和 `FROM` 子句是必需的，其他子句是可选的。

**子句功能**

1. SELECT：指定查询结果中要包含的列。
2. FROM：指定查询所涉及的表或视图。
3. WHERE：指定筛选条件，过滤行。
4. GROUP BY：将查询结果按指定列分组。
5. HAVING：指定筛选条件，过滤分组后的结果。
6. ORDER BY：指定排序规则。

### 4.4.2 简单查询

简单查询用于从单个表中检索数据。

```sql
SELECT Sno, Sname, Age FROM S WHERE SD = 'CS';
```

### 4.4.3 连接查询

连接查询涉及两个或多个表。

```sql
SELECT S.Sno, Sname
FROM S, SC
WHERE S.Sno = SC.Sno AND SC.Cno = 'C1';
```

### 4.4.4 子查询与聚集函数

#### 4.4.4.1 子查询

子查询是指一个 `SELECT` 查询嵌套在另一个查询中。

```sql
SELECT Sno, Sname
FROM S
WHERE Sno IN (SELECT Sno FROM SC WHERE Cno = 'C1');
```

#### 4.4.4.2 聚集函数

聚集函数用于对一组值执行计算并返回单个值。

| 聚集函数名       | 功能                           |
|------------------|--------------------------------|
| COUNT            | 统计元组个数                   |
| SUM              | 计算总和                       |
| AVG              | 计算平均值                     |
| MAX              | 求最大值                       |
| MIN              | 求最小值                       |

查询课程 C1 的最高分和最低分以及高低分之间的差距

```sql
SELECT MAX(Grade), MIN(Grade), MAX(Grade) - MIN(Grade)
FROM SC
WHERE Cno = 'C1';
```

查询所有比计算机系 CS 所有学生年龄都要小的学生的姓名及年龄。（用 ALL 谓词)

```sql
SELECT Sname, Age
FROM S
WHERE Age < ALL (SELECT Age FROM S WHERE SD = 'CS');
```

### 4.4.5 分组查询

#### 4.4.5.1 GROUP BY 子句

对查询结果进行分组。

```sql
SELECT Sno, AVG(Grade)
FROM SC
GROUP BY Sno;
```

#### 4.4.5.2 HAVING 子句

对分组后的结果进行筛选。

```sql
SELECT Jno, AVG(Qty)
FROM SPJ
GROUP BY Jno
HAVING COUNT(DISTINCT Sno) >= 3
ORDER BY Jno DESC;
```

### 4.4.6 更名运算

SQL 提供了为关系和属性重新命名的机制，通过 `AS` 子句实现。

```sql
Old-name AS new-name
```

### 4.4.7 字符串操作

使用 `LIKE` 操作符进行模式匹配，支持 `%`（匹配任意字符串）和 `_`（匹配任意单个字符）。

```sql
-- 示例：查询家庭住址包含“科技路”的学生姓名
SELECT Sname
FROM S
WHERE Add LIKE '%科技路%';

-- 示例：查询名字为“晓军”的学生的姓名、年龄和所在系
SELECT Sname, Age, SD
FROM S
WHERE Sname LIKE '_晓军';
```

### 4.4.8 视图查询

视图是从一个或多个基本表或视图中导出的表，用于简化查询和保护数据。

### 4.5 SQL 数据更新与访问控制

#### 4.5.1 插入（INSERT）

向表中插入数据，可以插入单个元组或通过查询语句插入多个元组。

```sql
INSERT INTO 表名 (列名1, 列名2, ...)
VALUES (值1, 值2, ...);
```

或通过查询插入：

```sql
INSERT INTO 表名 (列名1, 列名2, ...)
SELECT 查询语句;
```

#### 4.5.2 删除（DELETE）

从表中删除满足条件的元组。

```sql
DELETE FROM 表名
WHERE 条件表达式;
```

#### 4.5.3 修改（UPDATE）

更新表中满足条件的元组的属性值。

```sql
UPDATE 表名
SET 列名 = 新值
WHERE 条件表达式;
```

### 4.6 SQL 访问控制

管理用户对数据库的访问权限。

#### 4.6.1 授权（GRANT）

```sql
GRANT 权限 [, 权限] ...
ON [对象类型] 对象名
TO 用户名 [, 用户名] ...
[WITH GRANT OPTION];
```

WITH GRANT OPTION：若指定此子句，获得了权限的用户还可以将权限给其他用户

示例：授予用户 User1 和 User2 对表 S、P、J 的所有权限

```sql
GRANT ALL PRIVILEGES
ON TABLE S, P, J
TO User1, User2;
```

#### 4.6.2 收回权限（REVOKE）

```sql
REVOKE 权限 [, 权限] ...
ON [对象类型] 对象名
FROM 用户名 [, 用户名] ...;
```

```sql
-- 示例：收回用户 User1 和 User2 对表 S、P、J 的所有权限
REVOKE ALL PRIVILEGES
ON TABLE S, P, J
FROM User1, User2;

-- 收回所有用户对表 S 的查询权限：
REVOKE SELECT ON TABLE S FROM PUBLIC;

-- 收回 User1 对表 S 中 Sno 的修改权限：
REVOKE UPDATE(Sno) ON TABLE S FROM User1;
```

### 4.7 嵌入式 SQL

将 SQL 语句嵌入到高级语言中使用，需要区分主语言和 SQL 语句，嵌入时需加特定前缀（如 `EXEC SQL`）。

嵌入式 SQL 与主语言通信方式：

1. **SQL 通信区 (SQLCA)**：传递 SQL 执行状态。
2. **主变量**：传递参数。
3. **游标**：处理多记录。

示例（PL/1）：

```sql
EXEC SQL SELECT name, age, sex
INTO :NAME, :AGE, :SEX
FROM students
WHERE sno = :GIVENNO;
```

## 5 关系数据库的规范化

### 5.1 函数依赖

#### 1. 函数依赖的定义

函数依赖：设 $R(U)$ 是属性集 $U$ 上的关系模式，$X$、$Y$ 是 $U$ 的子集。若对 $R(U)$ 的任何一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称 $X$ 函数决定 $Y$，或 $Y$ 函数依赖于 $X$，记作 $X \to Y$。

#### 2. 平凡与非平凡函数依赖

* 平凡函数依赖：若 $Y \subseteq X$，则称 $X \to Y$ 是平凡的函数依赖。
* 非平凡函数依赖：若 $Y \nsubseteq X$，则称 $X \to Y$ 是非平凡的函数依赖。一般情况下总是讨论非平凡函数依赖。

#### 3. 完全与部分函数依赖

* 完全函数依赖：若 $X \to Y$，且对于 X 的任何一个真子集 $X'$，都有 $X' $ 不能决定 Y，则称 Y 对 X 完全函数依赖，记作 $X \overset{f}{\to} Y$。
* 部分函数依赖：若 $X \to Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ 部分函数依赖，记作 $X \overset{p}{\to} Y$。

#### 4. 传递依赖

传递依赖：在 $R(U, F)$ 中，若 $X \to Y$，$Y \nsubseteq X$，$Y \to Z$，则称 $Z$ 对 $X$ 传递依赖。

#### 5. 码与主属性

* 码：属性组 $K$ 是 $R$ 的码，若 $K$ 能函数决定 $U$，且 $K$ 的任何一个真子集都不能函数决定 $U$。
* 主属性与非主属性：包含在任何一个候选码中的属性称为主属性，否则称为非主属性。

#### 6. 外码

* **外码**：若 $R(U)$ 中的属性或属性组 $X$ 不是 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 为外码。

#### 7. 函数依赖的公理公式

以下是函数依赖的公理系统（Armstrong 公理系统）：

* 自反律：若 $Y \subseteq X \subseteq U$，则 $X \to Y$ 为 $F$ 所蕴涵。
* 增广律：若 $X \to Y$ 为 $F$ 所蕴涵，且 $Z \subseteq U$，则 $XZ \to YZ$ 为 $F$ 所蕴涵。
* 传递律：若 $X \to Y$，$Y \to Z$ 为 $F$ 所蕴涵，则 $X \to Z$ 为 $F$ 所蕴涵。

根据上述 3 条推理规则可推出下述 3 条推理规则：

* 合并规则：若 $X \to Y$，$X \to Z$，则 $X \to YZ$ 为 $F$ 所蕴涵。
* 伪传递率：若 $X \to Y$，$WY \to Z$，则 $XW \to Z$ 为 $F$ 所蕴涵。
* 分解规则：若 $X \to Y$，$Z \subseteq Y$，则 $X \to Z$ 为 $F$ 所蕴涵。

### 5.2 规范化

规范化的过程是将低级范式的模式转换为若干个高级范式的模式，以减少数据冗余、避免插入和删除异常、确保数据一致性。通常建议将数据库模式规范化到 3NF 或更高范式。

范式之间的关系：$5NF \subset 4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF$。

#### 5.2.1 1NF（第一范式）

* 定义：若关系模式 $R$ 的每一个分量是不可再分的数据项，则关系模式 $R$ 属于第一范式（1NF）。
* 问题：存在冗余度大、修改操作不一致、插入异常和删除异常等问题。

#### 5.2.2 2NF（第二范式）

* 定义：若关系模式 $R \in 1NF$，且每一个非主属性完全依赖于码，则关系模式 $R$ 属于第二范式（2NF）。
* 分解示例：将关系模式 $FIRST(Sno, Sname, Status, City, Pno, Qty)$ 分解为 $FIRST1(Sno, Sname, Status, City)$ 和 $FIRST2(Sno, Pno, Qty)$，其中 $FIRST1 \in 2NF$ 和 $FIRST2 \in 2NF$。

#### 5.2.3 3NF（第三范式）

* 定义：若关系模式 $R \in 2NF$，且不存在非主属性对码的传递函数依赖，则关系模式 $R$ 属于第三范式（3NF）。即当2NF 消除了非主属性对码的传递函数依赖。
* 分解示例：将关系模式 $FIRST1(Sno, Sname, Status, City)$ 分解为 $FIRST11(Sno, Sname, Status)$ 和 $FIRST12(Status, City)$，其中 $FIRST11 \in 3NF$ 和 $FIRST12 \in 3NF$。

### 5.3 模式分解

模式分解需保证无损连接（能还原原始关系）和保持函数依赖（不丢失原关系的约束规则）。

## 6 数据库的控制功能

### 6.1 事务管理

#### 6.1.1 事务的定义与特性

* 事务：是一个操作序列，要么全部完成，要么全部不做，是数据库环境中的逻辑工作单位。
* ACID 特性
  * 原子性（Atomicity）：事务的操作要么全做，要么全不做。
  * 一致性（Consistency）：事务执行结果必须保证数据库从一个一致性状态变到另一个一致性状态。
  * 隔离性（Isolation）：并发执行的事务之间相互隔离，每个事务的执行不受其他事务干扰。
  * 持久性（Durability）：一旦事务成功提交，其对数据库的更新将永久有效，即使数据库故障也不会丢失。

#### 6.1.2 SQL 中的事务控制语句

* BEGIN TRANSACTION：显式开始一个事务。
* COMMIT：提交事务，使所有操作永久生效。
* ROLLBACK：回滚事务，撤销所有操作。

### 6.2 数据库的备份与恢复

#### 6.2.1 故障类型

1. 事务故障：事务内部出错，可通过事务本身回滚处理。
2. 系统故障：导致系统停止运行，如 CPU 故障、操作系统错误等。
3. 介质故障：硬件损坏，如磁盘故障。
4. 计算机病毒：人为破坏数据库的程序。

#### 6.2.2 恢复方法

1. **建立冗余数据**：通过数据转储和建立日志文件实现。
   * **静态转储**：转储期间禁止数据库存取和修改。
   * **动态转储**：转储期间允许数据库存取和修改。
   * **日志文件**：记录事务操作序列，用于恢复。

2. **恢复步骤**：
   * **反向扫描日志文件**，查找事务的更新操作。
   * **对每个更新操作执行逆操作**。
   * **继续反向扫描日志文件**，直到事务的开始标志。

### 6.3 并发控制

#### 6.3.1 并发操作带来的问题

1. **丢失修改**：一个事务的修改被另一个事务覆盖。
2. **不可重复读**：一个事务读取到另一个事务未提交的修改。
3. **读取脏数据**：读取到未提交的修改，该修改可能被回滚。

#### 6.3.2 并发控制技术

* **封锁机制**：通过加锁防止并发操作导致的数据不一致。
  * **排他锁（X 锁）**：禁止其他事务读取或修改。
  * **共享锁（S 锁）**：允许多个事务读取，但禁止修改。
* **封锁协议**：
  * **一级封锁协议**：事务在修改数据前加 X 锁，结束时释放。
  * **二级封锁协议**：在一级基础上，读数据前加 S 锁，读完即释放。
  * **三级封锁协议**：在一级基础上，读数据前加 S 锁，结束时释放。
* **活锁与死锁**：
  * **活锁**：事务因不断请求被拒绝而长时间等待。
  * **死锁**：两个或多个事务互相等待对方释放锁。
* **并发调度的可串行性**：并发执行的结果与某一次序的串行执行结果相同。
* **两段锁协议**：事务分加锁和解锁两个阶段，确保可串行性。
* **封锁的粒度**：封锁对象的大小，可以是逻辑单元（如属性、关系）或物理单元（如数据页）。
