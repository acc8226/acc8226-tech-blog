---
title: 05. Kotlin 函数
date: 2023-01-03 17:56:00
updated: 2023-01-03 17:56:00
categories:
  - 语言
  - Kotlin
tags:
- kotlin
---

函数是能完成某项特定任务的可复用代码块，是编程非常重要的一部分。事实上，程序基本上就是一系列函数的组合，用来完成较复杂的任务。

## 函数声明

Kotlin 中的函数很灵活，它可以独立于类或接口之外存在，即顶层函数，也就是全局函数，之前接触的 main 函数就属于顶层函数；也可以存在于别的函数中，即局部函数；还可以存在于类或接口之中，即成员函数。

```kt
fun 函数名(参数列表) : 返回值类型 {
    函数体
    return 返回值
}
```

在参数列表后“: 返回值类型”指明函数的返回值类型，如果函数没有需要返回的数据，则 “: 返回值类型” 部分可以省略。对应地，如果函数有返回数据，就需要在函数体最后使用 return 语句将计算的数据返回；如果没有返回数据，则函数体中可以省略 return 语句。

举例：具有两个 Int 参数和 Int 返回类型的函数。

```kt
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

不返回任何有意义值的函数。

```kt
fun printSum(a: Int, b: Int): Unit {
    println("sum of $a and $b is ${a + b}")
}
```

Unit 返回类型可以省略。

```kt
fun printSum(a: Int, b: Int) {
    println("sum of $a and $b is ${a + b}")
}
```

### 函数参数

Kotlin 中的函数参数很灵活，具体体现在传递参数有多种形式上。

### Default Parameter Values 参数默认值

在声明函数的时候可以为参数有默认值，这些值在跳过相应的参数时使用。这减少了过载的数量。

默认值通过向类型追加 = 来设置。

```kt
fun printMessageWithPrefix(message: String, prefix: String = "Info") {
    println("[$prefix] $message")
}

printMessageWithPrefix("Hello")
```

### Named Arguments 命名参数

为了提高函数调用的可读性，在函数调用时可以采用命名参数调用。采用命名参数调用函数声明时不需要做额外的工作。

```kt
printMessageWithPrefix(prefix = "Log", message = "Hello")

### 可变参数(varargs)

Kotlin 中函数的参数个数可以变化，它可以接受不确定数量的输入类型参数（这些参数具有相同的类型），有点像是传递一个数组。可以通过在参数名前面加 vararg 关键字的方式来表示这是可变参数(通常是最后一个) 。

```kt
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
```

## 返回特殊数据

在函数体中可以通过 return 语句返回数据，返回数据类型要与函数声明的数据类型保持一致。本节讨论一些特殊的返回数据，其中包括：无返回数据和永远不会正常返回数据。

### 无返回数据与 Unit 类型

如果函数只是为了处理某个过程, 不需要返回具体数据，例如 println 函数。则其返回类型为 Unit。Unit 是只有一个值的类型 Unit。此值不必显式返回:

```kt
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello $name")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
```

Unit 返回类型声明也是可选的:

```kt
fun printHello(name: String?) { ... }
```

### 永远不会正常返回数据与 Nothing 类型

Kotlin 中提供一种特殊的数据类型 Nothing，Nothing 只用于函数返回类型声明，不能用于变量声明。Nothing声明的函数永远不会正常的返回，只会抛出异常。

## single-expression function 单表达式函数

如果在函数体中表达式能够表示成为单个表达式时，那么返回类型、花括号、返回语句都可以省掉。表示方式更加简单。

```kt
fun sum(a: Int, b: Int) = a + b
```

## 局部函数

在本节之前声明的函数都是顶层函数，函数还可声明在类内部和另一个函数的内部，在类内部称为成员函数，在另一个函数内部称为局部函数。

局部函数可以访问所在外部函数中的变量。但是内部函数的作用域在外函数体内，因此直接访问局部函数会发生编译错误。

## 匿名函数

Kotlin 中可以使用匿名函数，匿名函数不需要函数名，需要 fun 关键字声明，还需要有参数列表和返回类型声明，函数体中需要包含必要的 return 语句。

函数类型定义包括两个部分，它们以箭头符号隔开：一对圆括号里面的函数参数和紧跟着的返回数据类型。

和具名函数一样，匿名函数可以不带参数，也可以带一个或多个任何类型的参数。需要带参数时，参数的类型放在匿名函数的类型定义中，参数名则放在函数定义中。

### it 关键字

定义只有一个参数的匿名函数时，可以使用 it 关键字来表示参数名。

### 类型推断

Kotlin 的类型推断规则同样也适用函数类型，但为了帮助编译器更准确地推断变量类型，匿名函数的参数名和参数类型必须有。

```kt
val greetingFunction6 = { playerName: String, numBuildings: Int ->
    val currentYear = 2025
    println("Adding $numBuildings houses")
    "Welcome to SimVillage, $playerName! (copyright $currentYear)"
}
```

### 函数内联

lambda 可以让你更灵活地编写应用。然而，灵活也是要付出代价的。

在 JVM 上，你定义的 lambda 会以对象实例的形式存在。JVM 会为所有同 lambda 打交道的变量分配内存，这就产生了内存开销。更糟的是，lambda 的内存开销会带来严重的性能问题。显然，这种性能问题应当避免。

幸运的是，Kotlin 有一种优化机制叫内联，可以解决 lambda 引起的内存开销问题。有了内联，JVM 就不需要使用 lambda 对象实例了，因而避免了变量内存分配。

为了使用内联方法优化 lambda，以 **inline** 关键字标记使用 lambda 的函数即可。

### 函数引用

到目前为止，要把函数作为参数传给其他函数使用，我们都是先定义一个 lambda，然后把它作为参数传给另一个函数使用。除了传 lambda 表达式，Kotlin 还提供了其他方法：传递函数引用。函数引用可以把一个具名函数（使用 fun 关键字定义的函数）转换成一个值参。凡是使用lambda 表达式的地方，都可以使用函数引用。

要获得函数引用，使用 :: 操作符，后跟要引用的函数名。

函数引用在很多场景都很有用。例如，如果需要一个具名函数作为值参传给其他函数，采用 函数引用方法代替 lambda 就能达到同样的目的。或者在需要使用 Kotlin 标准库函数作为值参传 给其他函数使用时，也可以使用函数引用。

### 函数类型作为返回类型

和其他数据类型一样，函数类型也是有效的返回类型，也就是说，你可以定义一个能返回函数的函数。

```kt
// 函数类型作为返回类型
fun configureGreetingFunction(): (String) -> String {
    val structureType = "hospitals"
    var numBuildings = 5
    return { playerName: String ->
        val currentYear = 2018
        numBuildings++
        println("Adding $numBuildings $structureType")
        "Welcome to SimVillage, $playerName! (copyright $currentYear)"
    }
}
```

能接受函数（以函数值参传入）或者返回函数的函数又叫高级函数。高级函数和 lambda 术语来自同一数学领域。高级函数广泛应用于函数式编程这种编程范式中。

## Infix Functions 中缀函数

具有单个参数的成员函数和扩展可以转换为中缀函数。

```kt
infix fun Int.times(str: String) = str.repeat(this)
println(2 times "Bye ")
```
