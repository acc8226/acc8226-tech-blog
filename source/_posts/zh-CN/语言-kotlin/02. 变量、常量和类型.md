---
title: 02. Kotlin 变量、常量和类型
date: 2022-10-07 21:44:00
updated: 2022-10-07 21:44:00
categories:
  - 语言
  - Kotlin
tags:
- kotlin
---

## 数据类型

### 数值类型

在 Kotlin，一切都是一个对象，你可以调用任何变量的成员函数和属性。有些类型可以有一个特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为基本值——但对用户来说，它们看起来像普通类。

Kotlin 这样设计基于几大理由。首先，只有一种数据类型可选，你就不容易因选项多而选错， 进而陷入编码困境。例如，定义了一个基本数据类型实例后，写着写着，猛然发现要用到只有引 用类型才支持的泛型功能，怎么办？Kotlin 通过只提供一种类型规避了此问题。也许熟悉 Java 的你会说：“但是基本数据类型的性能要好于引用类型啊！”。为了让你愉快地使用引用类型，Kotlin 编译器会根据不同的场景将其编译成为 Java 中的基本类型数据还是包装类对象。假如你熟悉 Java 的八大基本数据类型，也能在 Kotlin 中分别找到它们的对应引用数据类型。

* 整数类型：Byte、Short、Int 和 Long，Int 是默认类型。
* 浮点类型：Float 和 Double，Double 是默认类型。
* 字符类型：Char。
* 布尔类型：Boolean

#### 整数类型

Kotlin 提供了一组表示数字的内置类型。对于整数，有四种不同大小的类型（Byte、Short、Int 和 Long）。

当初始化没有显式类型规范的变量时，编译器会自动推断出具有足以表示该值的最小范围的类型。如果不超过 Int 的范围，则该类型为 Int。如果超过，则类型为 Long。若要显式指定 Long 值，请将后缀 L 附加到该值。显式类型规范触发编译器检查值是否不超过指定类型的范围。

```kt
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

除了整数类型之外，Kotlin 还为无符号整数提供了以下类型:

UByte: an unsigned 8-bit integer, ranges from 0 to 255
UShort: an unsigned 16-bit integer, ranges from 0 to 65535
UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1
ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1

未签名类型支持其对应的已签名类型的大多数操作。

##### 显式数字转换

由于表示形式不同，较小的类型不是较大类型的子类型。所有数字类型都支持转换为其他类型:

* toByte(): Byte
* toShort(): Short
* toInt(): Int
* toLong(): Long
* toFloat(): Float
* toDouble(): Double

在许多情况下，不需要显式转换，因为类型是从上下文推断出来的，并且对于适当的转换，算术操作是重载的，例如:

```kt
val l = 1L + 3 // Long + Int => Long
```

#### 浮点类型

对于实数，Kotlin 提供了遵循 IEEE 754 标准的浮点类型 Float 和 Double。Float 反映 IEEE 754 的单精度，而 Double 反映的是双精度。

可以使用具有小数部分的数字初始化 Double 和 Float 变量。它与整数部分之间用句点(.)隔开对于用小数初始化的变量，编译器推断出 Double 类型:

```kt
val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
```

若要显式指定值的 Float 类型，请添加后缀 f 或 F。如果该值包含超过6-7个小数位，它将被四舍五入:

```kt
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, actual value is 2.7182817
```

与其它一些语言不同，Kotlin 没有隐式的数字扩大转换。例如，带有 Double 参数的函数只能在 Double 值上调用，而不能在 Float、 Int 或其他数值上调用:

```kt
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1
    val d = 1.0
    val f = 1.0f

    printDouble(d)
//    printDouble(i) // Error: Type mismatch
//    printDouble(f) // Error: Type mismatch
}
```

若要将数值转换为不同类型，请使用显式转换。

### 数字的字面常数

 在 Java 中表示 long 类型整数时可以在数字后面加小写英文字母 l，但由于可读性不好，容易被误认为是阿拉伯数字 1，所以在 Kotlin 中部不允许这样表示。

在使用整数变量赋值，还可以使用二进制和十六进制表示，**但不支持八进制**，它们的表示方式分别如下：

* 二进制数：以 0b 或 0B 为前缀，注意 0 是阿拉伯数字，不要误认为是英文字母 o。
* 十六进制数：以 0x 或 0X 为前缀，注意 0 是阿拉伯数字。

可以使用下划线使数字常量更易读:

```kt
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### 字符类型

和 Java 一样, 字符类型表示单个字符，Kotlin 中 Char 声明字符类型，Kotlin 中的字符常量必须用单引号括起来的单个字符。

Kotlin 字符采用双字节 Unicode 编码，占**两个字节（16位）**，因而可用十六进制（无符号的）编码形式表示，它们的表现形式是`\uXXXX`，其中`XXXX`为 16 位十六进制数，所以'A'字符也可以用Unicode编码'\u0041'表示，如果对字符编码感兴趣可以到维基百科（[https://zh.wikipedia.org/wiki/Unicode](https://zh.wikipedia.org/wiki/Unicode)字符列表）查询。

#### 转义字符(和 java 一致)

![常用转义符](https://upload-images.jianshu.io/upload_images/1662509-bb5c986ace88236d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 常量和变量

Kotlin 有强大的类型推断能力。虽然你可以显式地声明变量的类型，但通常会让编译器通过推断来完成这项工作。Kotlin 并不强制执行不变性，尽管它是被推荐的。本质上使用 val/var。

在 Kotlin 中声明变量，就是在标识符的前面加上关键字 var。
变量一旦赋值就不能更改。要声明只读变量，使用 val 关键字。常量一旦初始化后就不能再被修改。

```kt
var a: String = "initial"  // 1
println(a)
val b: Int = 1             // 2
val c = 3                  // 3
```

1. 声明一个变量 var 并初始化它。
2. 声明一个不可变变量 val 并初始化它。
3. 声明一个不可变变量，并在不指定类型的情况下初始化它。

你可以自由选择何时初始化变量，但是，它必须在第一次读之前初始化。

```kt
val d: Int  // 1

if (someCondition()) {
    d = 1   // 2
} else {
    d = 2   // 2
}

println(d) // 3
```

1. 声明一个没有初始化的变量。
2. 根据某些条件使用不同的值初始化变量。
3. 读取变量是可能的，因为它已经被初始化了。

您可以在顶层声明变量。

```kt
val PI = 3.14
var x = 0

fun incrementX() {
    x += 1
}
```

### 编译时常量

编译时常量使用 `const val` 进行修饰。

编译时常量只能在函数（指包括 main 在内的所有函数）之外定义。这是因为编译时常量 必须在编译时（程序编译时）赋值，而 main 和其他函数都是在运行时（程序运行时）才调用， 函数内的变量也是在那时赋值。编译时常量要在这些变量赋值前就已存在。因为使用复杂的数据类型可能会危害编译时的安全保障，所以编译时常量只能是一些常见的基本数据类型。

* String
* Int
* Double
* Float
* Long
* Short
* Byte
* Char
* Boolean

```kt
const val MAX_EXPERIENCE: Int = 5000
```

### 思考：使用 var 还是 val

如果两种方式都能满足需求情况下，原则上优先考虑使用 val 声明。因为一方面 val 声明的变量是只读，一旦初始化后不能修改，这可以避免程序运行过程中错误地修改变量内容；另一方面在声明引用类型使用 val，对象的引用不会被修改，但是引用内容可以修改，这样会更加安全，也符合函数式编程的技术要求。

## Null Safety

为了消除 NullPointerException，Kotlin 的变量类型不允许赋值 null。如果您需要一个可以为空的变量，可以通过添加？在其类型的末端。

### 可空类型

有时候，Kotlin 程序需要使用 null 值，例如在与外部 Java 代码交互时，或者表示一个真正缺失的状态时。Kotlin 提供空跟踪来优雅地处理这种情况。

Kotlin 为每一种非空类型提供对应的可空类型（Nullable），就是在非空类型后面加上问号（?）表示可空类型。 `var n: Int? = 10`

Int? 是可空类型，它所声明的变量 n 可以接收空值。

```kt
var nullable: String? = "You can keep a null here"
nullable = null
```

1. 接受可为空的字符串并返回其说明的函数。
2. 如果给定的字符串不为空，也不为空，则返回有关其长度的信息。
3. 否则，告诉调用方字符串为空或 null。

可空类型在具体使用时会有一些限制：

* 不能直接调用可空类型对象的函数或属性。
* 不能把可空类型数据赋值给非空类型变量。
* 不能把可空类型数据传递给非空类型参数的函数。

## 类型转换

### 数值类型之间的转换

本节讨论数值类型之间互相转换，**数值**在进行赋值时采用的是**显示转换**，而在**数学计算**时采用的是**隐式转换**。

#### 赋值与显式转换

Kotlin 是一种安全的语言，对于类型的检查非常严格，不同类型数值进行赋值是禁止的. Kotlin中要想实现这种赋值转换，需要使用转换函数显式转换。Kotlin 的 6 种数值类型（Byte、Short、Int、Long、Float 和 Double），以及Char类型都有如下 7 个转换函数：

* toByte(): Byte
* toShort(): Short
* toInt(): Int
* toLong(): Long
* toFloat(): Float
* toDouble(): Double
* toChar(): Char

#### 数学计算与隐式转换

多个数值类型数据可以数学计算，由于参与进行数学计算的数值类型可能不同，编译器会根据上下文环境进行隐式转换。

## 参考

Kotlin 编程权威指南
<https://www.ituring.com.cn/book/tupubarticle/27591?bookID=2610>
