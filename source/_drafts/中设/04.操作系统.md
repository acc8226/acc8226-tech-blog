# 04 操作系统

## 进程管理-状态管理和前趋图

# 进程管理知识点总结

## 1 进程的基本概念

- **定义**：进程是程序的一次动态执行过程，是系统进行资源分配和调度的基本单位。
- **特点**
  - 动态性：进程具有生命周期，有创建、运行和消亡的过程。
  - 并发性：多个进程可以在同一时间段内并发执行。
  - 独立性：进程是独立运行的单位，具有独立的资源和状态。
  - 异步性：进程的执行速度不可预知，按随机速度向前推进。
- **组成**
  - 程序：包含要执行的指令集合。
  - 数据：运行过程中使用的数据。
  - 程序控制块（PCB）：记录进程的状态信息，是进程存在的唯一标识。

## 2 进程的状态

- **三态模型**
  - **运行态**：进程正在CPU上运行。
  - **就绪态**：进程已准备好运行，但等待CPU分配。
  - **阻塞态**：进程因等待某种事件（如I/O操作完成）而暂停运行。
- **五态模型**
  - 在三态模型基础上增加了“新建态”和“终止态”。
  - **新建态**：进程刚被创建，尚未进入就绪队列。
  - **终止态**：进程运行结束，资源被回收。

## 3 进程的创建与终止

- **创建**
  - 系统调用：用户通过系统调用请求创建进程。
  - 系统创建PCB，分配资源，并将进程置入就绪队列。
- **终止**
  - 进程运行结束或因异常被终止。
  - 系统回收资源，撤销PCB。

## 四、进程调度

- **三级调度**
  - **高级调度**：决定是否创建进程，控制多道程序的数量。
  - **中级调度**：内存管理，决定进程是否进入内存。
  - **低级调度**：决定哪个就绪态进程获得CPU。
- **调度算法**
  - **先来先服务（FCFS）**：按进程到达顺序调度。
  - **时间片轮转（RR）**：每个进程分配固定时间片，轮流运行。
  - **优先级调度**：根据进程优先级进行调度。
  - **多级反馈队列调度**：结合多种调度算法，提高系统效率。

## 五、进程的同步与互斥

- **同步机制**
  - 用于协调进程间的逻辑关系，确保按特定顺序执行。
  - 常见机制：信号量、管程等。
- **互斥机制**
  - 用于防止多个进程同时访问共享资源。
  - 常见机制：互斥锁、信号量等。
- **信号量机制**
  - **PV操作**：P操作（等待）和V操作（信号）。
  - **实现**：通过信号量控制进程的同步和互斥。
- **临界区管理原则**
  - **有空即进**：资源空闲时立即进入。
  - **无空则等**：资源被占用时等待。
  - **有限等待**：等待时间有限。
  - **让权等待**：等待时释放CPU。

## 六、进程间通信（IPC）

- **管道**
  - 单向通信，用于父子进程或同父进程间通信。
- **消息队列**
  - 存储消息，进程间通过消息队列通信。
- **共享内存**
  - 多个进程共享同一内存区域，提高通信效率。
- **信号量**
  - 用于同步和互斥，控制进程对共享资源的访问。

## 信号量 PV 操作

## 一、信号量PV操作的基本概念

- **信号量（Semaphore）**：一种用于同步和互斥访问共享资源的机制，是一个计数器，可以被多个进程共享。
- **P操作（等待操作）**：
  - 将信号量的值减1。
  - 如果信号量的值大于0，表示资源可用，进程可以继续执行。
  - 如果信号量的值等于0，表示资源不可用，进程将被阻塞，直到资源可用。
- **V操作（释放操作）**：
  - 将信号量的值加1。
  - 如果有其他进程因为等待资源而被阻塞，将其中一个被阻塞的进程唤醒[^13^]。

## 二、信号量PV操作的应用场景

### （一）实现进程互斥

- **互斥信号量S的定义**：S的初值设为1，表示当前没有进程在临界区，可以进入临界区。
  - **S = 1**：表示没有进程在进入临界区，即可以有一个进程进入。
  - **S = 0**：表示已有一个进程进入临界区，其他进程必须等待。
  - **S < 0**：表示已有一个进程进入临界区，且有|S|个进程在等待进入临界区。
- **PV操作表示进程对临界区的申请和释放**：
  - **进入临界区之前**：进程要进入临界区时，首先执行P(S)操作，即“申请”信号量S。
  - **退出临界区之后**：当进程完成临界区操作后，执行V(S)操作，即“释放”信号量S。

### （二）实现进程同步

- **同步机制**：用于确保多个并发进程能够正确、有序地协作，避免数据冲突和确保数据一致性[^10^]。
- **PV操作实现进程的同步**：
  - **P操作**：测试消息是否到达。如果信号量S的值大于0，进程继续执行并进入临界区；如果信号量S的值小于等于0，进程进入等待状态，直到信号量S的值大于0[^10^]。
  - **V操作**：发送消息。增加信号量S的值，唤醒因等待信号量而阻塞的进程[^10^]。
- **生产者消费者问题**：
  - **生产者操作**：
    ```c
    while (true) {
        produce();     // 生产一个项目
        P(empty);      // 等待缓冲区有空位
        P(mutex);      // 进入临界区，互斥访问缓冲区
        add_to_buffer(); // 将项目添加到缓冲区
        V(mutex);      // 离开临界区
        V(full);       // 增加缓冲区产品数
    }
    ```
  - **消费者操作**：
    ```c
    while (true) {
        P(full);       // 等待缓冲区有产品
        P(mutex);      // 进入临界区，互斥访问缓冲区
        remove_from_buffer(); // 从缓冲区移除一个项目
        V(mutex);      // 离开临界区
        V(empty);      // 增加缓冲区空位数
        consume();     // 消费这个项目
    }
    ```

## 三、信号量PV操作的实现

### （一）基于系统V信号量的实现

- **代码示例**：

  ```c
  #include <semaphore.h>
  #include <stdio.h>
  #include <sys/sem.h>
  #include <sys/ipc.h>
  #include <unistd.h>
  #define SEM_KEY 12345 // 信号量的键值

  // 初始化信号量
  int init_semaphore(int sem_id, int sem_value) {
      struct sembuf sem_b;
      sem_b.sem_num = 0;
      sem_b.sem_op = 0;
      sem_b.sem_flg = 0;
      if (semctl(sem_id, 0, SETVAL, sem_value) == -1) {
          perror("Failed to set value of semaphore");
          return -1;
      }
      return 0;
  }

  int main() {
      int sem_id;
      key_t key = SEM_KEY;
      // 创建信号量
      sem_id = semget(key, 0, 0666);
      if (sem_id == -1) {
          printf("Cannot get semaphore.\n");
          return -1;
      }
      // 尝试获取信号量
      struct sembuf sem_b;
      sem_b.sem_num = 0;
      sem_b.sem_op = -1; // P操作
      sem_b.sem_flg = SEM_UNDO;
      if (semop(sem_id, &sem_b, 1) == -1) {
          perror("Failed to acquire semaphore");
      } else {
          // 执行写入操作
          printf("Write operation in progress...\n");
          sleep(5); // 模拟写入操作耗时
          // 释放信号量
          sem_b.sem_op = 1; // V操作
          if (semop(sem_id, &sem_b, 1) == -1) {
              perror("Failed to release semaphore");
          }
      }
      return 0;
  }

## 死锁

-定义：多个进程因互相等待资源而无法继续运行的状态。
-产生原因 资源分配不当，进程推进顺序不合理。

-产生条件**
**互斥条件**：资源不能同时共享。
**请求保持条件**：进程已占用资源，又请求新资源。
**不可剥夺条件**：已分配的资源不能被强制剥夺。
**环路条件**：存在资源分配环路。

-处理方法**
**预防**：破坏死锁产生的条件之一。
**避免**：银行家算法，动态检测死锁。
**检测**：定期检测系统是否死锁。
**解除**：剥夺资源或撤销进程。


# 页式存储管理

## 一、基本概念
- 定义：页式存储管理是一种将主存划分为大小相等的若干个页面的存储管理方式。
- 逻辑地址空间与物理地址空间：
  - 将用户程序的逻辑地址空间划分为若干个长度相等的页。
  - 将物理内存空间按页的大小划分为片或页面。
- 页表：页式存储管理采用页表来实现逻辑地址到物理地址的映射。

## 二、工作原理
- 地址转换：
  - 当进程访问虚拟地址时，操作系统通过查找页表，将虚拟地址转换为相应的物理地址[^19^]。
  - 虚拟地址由页号和页内偏移量组成，通过页表找到对应的物理页框号，再结合页内偏移量得到物理地址[^18^]。
- **页面置换**：
  - 当物理内存不足时，操作系统会根据页面置换算法选择一些不常用的页面置换到磁盘上[^19^]。
  - 常见的页面置换算法有先进先出（FIFO）、最近最少使用（LRU）等。
- **缺页处理**：
  - 当进程访问的虚拟页面不在物理内存中时，会发生缺页中断[^19^]。
  - 操作系统会根据缺页中断的处理程序，将所需的页面从磁盘上加载回物理内存，并更新页表和进程的上下文信息[^19^]。

## 三、优缺点

### （一）优点

- **无外碎片**：页式存储管理没有外碎片，每个内碎片不超过页的大小[^17^]。
- **动态分配**：允许程序在执行过程中根据需要动态地调入和调出内存中的页[^17^]。
- **提高利用率**：通过将物理内存划分为固定大小的页面，提高了内存的利用率[^20^]。
- **便于内存保护**：每个页面都有独立的地址空间，便于实现内存保护[^20^]。

### （二）缺点

- **硬件要求高**：要求有相应的硬件支持，如地址变换机构、缺页中断的产生和选择淘汰页面等，增加了机器成本和系统开销[^17^][^20^]。
- **地址转换开销**：每次访问内存都需要进行地址转换，效率较低[^20^]。

## 四、实现方式

- **页表的创建和维护**：操作系统通过建立和维护页表，将虚拟地址转换为物理地址[^19^]。
- **页面置换算法**：选择合适的页面置换算法以提高内存利用率[^19^]。
- **内存共享**：通过设置相应的权限位，控制不同进程对共享内存的访问权限。

好的，以下是软考中级软件设计师中存储管理部分关于段式存储和段页式存储的总结，以 Markdown 格式输出：


# 存储管理：段式存储与段页式存储

## 一、段式存储管理

### （一）基本概念
- **定义**：段式存储管理是根据程序的逻辑结构将程序划分为若干个逻辑段，每个段是一个独立的逻辑地址空间。
- **逻辑地址结构**：逻辑地址由段号和段内偏移量组成。

### （二）工作原理

- **段表**：系统为每个进程建立一张段表，段表项包含段号、段起始地址、段长度等信息。
- **地址转换**：CPU访问内存时，根据逻辑地址中的段号查找段表，找到对应的段起始地址和段长度，然后检查段内偏移量是否越界。若未越界，则将段起始地址与段内偏移量相加得到物理地址。

### （三）优缺点

- **优点**
  - **逻辑划分清晰**：符合程序的逻辑结构，便于程序的组织和管理。
  - **便于共享和保护**：每个段可以有不同的访问权限，有助于内存保护和数据共享。
  - **动态内存分配**：段的大小可以动态变化，便于动态申请内存。
- **缺点**
  - **产生碎片**：会产生外部碎片，因为段的大小不是固定的，可能导致内存空间无法被充分利用。
  - **内存利用率低**：由于段的大小不固定，内存分配可能存在浪费。

## 二、段页式存储管理

### （一）基本概念

- **定义**：段页式存储管理是将段式存储和页式存储相结合的一种内存管理方式。先将程序按逻辑结构划分为多个段，再将每个段细分为固定大小的页面。
- **逻辑地址结构**：逻辑地址由段号、段内页号和页内地址三部分组成。

### （二）工作原理

- **段表和页表**：系统为每个进程建立一张段表，用于管理段的分配和访问。每个段再建立一张页表，用于管理段内页面的分配和访问。
- **地址转换**：逻辑地址由段号、段内页号和页内地址三部分组成。首先通过段表找到对应的段，再通过页表找到对应的物理页面，最后将物理页面号与页内地址组合成物理地址。

### （三）优缺点

- **优点**
  - **结合了段式和页式的优点**：既保持了程序的逻辑结构，又提高了内存利用率。
  - **灵活的内存保护**：段的划分使得不同的程序部分可以有不同的保护级别，增强了内存的安全性。
  - **便于程序的组织**：段式划分符合程序的逻辑结构，便于程序的编写和维护。
- **缺点**
  - **管理复杂性增加**：段页式存储的管理比单纯的段式或页式存储更为复杂，需要维护段表和页表。
  - **性能开销**：地址转换过程中的额外步骤可能导致性能开销，尤其是在地址转换频繁的情况下。

# 设备管理

## 设备管理概述
- 设备管理是操作系统的一项重要功能，负责管理计算机系统中的各种硬件设备，包括输入设备、输出设备和存储设备等。
- 主要任务包括设备的分配、控制和调度，以保证设备的效率和公平性。

## 设备分类

### 按数据组织分类

- **块设备**：以固定大小的块为单位进行数据传输的设备，如硬盘、固态硬盘。
- **字符设备**：以字符为单位进行数据传输的设备，如键盘、鼠标、打印机。

### 按资源分配分类

- **独占设备**：一次只能被一个程序使用的设备，如硬盘、串口。
- **共享设备**：可以被多个程序同时使用的设备，如打印机。
- **虚拟设备**：通过软件模拟出来的设备，如虚拟机的虚拟硬盘、虚拟网络适配器。

### 按传输速率分类

- **低速设备**：传输速率较慢的设备，如鼠标、键盘。
- **中速设备**：传输速率适中的设备，如打印机。
- **高速设备**：传输速率较快的设备，如硬盘、固态硬盘。

## I/O控制方式
- **程序直接控制方式**：CPU主动查询外设是否完成数据传输，效率低，适用于低速设备、非实时性要求高的场景。
- **程序中断方式**：外设完成数据传输后，向CPU发送中断，效率相对较高，适用于键盘等实时性较高的场景。
- **DMA方式（直接主存存取）**：数据传输由DMA控制器完成，CPU仅需完成初始化操作，效率高，适用于硬盘等高速设备。
- **通道控制方式**：通过专用通道控制设备输入输出，效率高，但复杂度高，适用于大规模、高速设备。
- **IO处理机**：专用设备处理输入输出请求，减轻CPU负担，效率高，适用于处理大量且需要复杂逻辑的设备输入输出请求。

## 设备分配与管理

- 系统为每个设备建立一个设备控制块（DCB），用于描述设备的状态和属性。
- 当进程或用户需要使用设备时，系统会查找可用的设备并分配给它。
- 设备管理程序提供与进程管理系统的接口，进行设备分配，实现设备和设备之间、设备和CPU之间的并行操作，进行缓冲区管理。

## 设备驱动程序

- 设备驱动程序是操作系统中的一段代码，用于与硬件设备进行通信和交互。
- 功能是将操作系统的请求转换为设备所能理解的命令，并将设备的响应传递给操作系统。

## SPOOLing 技术

- SPOOLing（Simultaneous Peripheral Operations On-line）技术是一种计算机输入/输出（I/O）管理技术，通过将多个I/O请求缓存到磁盘或内存中的输入/输出队列（spool）中，然后按照一定的顺序依次处理这些请求。
- 作用是提高计算机的效能和性能，避免进程等待I/O操作完成而导致CPU空闲的情况，增加系统的灵活性和可扩展性。

## 磁盘结构与调度算法

- 磁盘有正反两个盘面，每个盘面有多个同心圆（磁道），每个磁道又被划分为多个扇区。数据存放在扇区中。读取数据时，会产生寻道时间和等待时间。

磁盘访问时间主要由三部分组成：寻道时间、旋转延迟时间和数据传输时间

寻道时间是指磁头从当前位置移动到目标磁道所需的时间。它取决于磁头的移动速度和目标磁道与当前磁道的距离。寻道时间的计算公式为：
寻道时间=(目标磁道号−当前磁道号)×寻道速度
其中，寻道速度是磁头每跨越一个磁道所需的时间。

旋转延迟时间是指等待所需数据扇区旋转到磁头下方的时间

数据传输时间是指数据从磁盘传输到内存的时间，它取决于数据量和传输速率。数据传输时间的计算公式为：
数据传输时间= 传输速率 /数据量

- **磁盘调度算法**：
  - **先来先服务（FCFS）**：根据进程请求访问磁盘的先后顺序进行调度。
  - **最短寻道时间优先（SSTF）**：选取与当前磁头位置最近的磁道进行调度，可能导致远处进程无法访问（饥饿现象）。
  - **扫描算法（SCAN）**：又称“电梯算法”，磁头双向移动，选择离磁头当前位置最近的请求访问磁道，并且与磁头移动方向一致。
  - **单向扫描调度算法（CSCAN）**：与 SCAN 不同的是，只做单向移动。

# 文件管理

## 文件管理概述
文件管理是操作系统的重要组成部分，负责管理和组织计算机系统中的文件和目录。它提供了文件的存储、检索、更新和共享等功能，确保文件的安全性和一致性。

## 文件的逻辑结构
- **定义**：文件是具有名字的一组相关信息的集合，是命名的相关信息的集合。
- **分类**：
  - **普通文件**：包含用户数据的文件，如文本文件、图像文件等。
  - **目录文件**：包含文件或目录的文件，用于组织和管理文件。
  - **特殊文件**：用于设备驱动程序的文件，如设备文件。
- **逻辑结构类型**：
  - **流式文件**：文件中的信息是一个字符序列，没有结构。
  - **记录式文件**：文件中的信息被组织成若干个记录，每个记录有固定的格式和长度。

## 文件的物理结构
- **定义**：文件的物理结构是指文件在存储介质上的存储方式。
- **物理结构类型**：
  - **连续结构**：文件的所有块在存储介质上是连续的。
  - **链接结构**：文件的块通过指针链接在一起。
  - **索引结构**：文件的块通过索引表进行管理，索引表中包含每个块的地址。

## 文件的目录结构
- **定义**：目录是文件的集合，用于组织和管理文件。
- **目录结构类型**：
  - **单级目录结构**：所有文件都存储在一个目录中。
  - **二级目录结构**：每个用户有一个自己的目录。
  - **多级目录结构**：目录可以嵌套，形成树形结构。

## 文件存储空间的管理
- **定义**：文件存储空间的管理是指对文件存储空间的分配和回收。
- **存储空间分配方法**：
  - **连续分配**：为文件分配连续的存储空间。
  - **链接分配**：为文件分配不连续的存储空间，通过指针链接。
  - **索引分配**：为文件分配不连续的存储空间，通过索引表管理。
- **存储空间回收**：当文件被删除时，回收其占用的存储空间。

## 文件操作
- **定义**：文件操作是指对文件进行的各种操作，如创建、删除、打开、关闭、读取、写入等。
- **常见文件操作**：
  - **创建文件**：创建一个新的文件。
  - **删除文件**：删除一个已存在的文件。
  - **打开文件**：打开一个已存在的文件，以便进行读写操作。
  - **关闭文件**：关闭一个已打开的文件。
  - **读取文件**：从文件中读取数据。
  - **写入文件**：向文件中写入数据。
  - **文件定位**：定位到文件中的某个位置。
  - **文件复制**：复制一个文件。
  - **文件移动**：移动一个文件。
  - **文件重命名**：重命名一个文件。

## 文件共享与保护
- 定义：文件共享是指多个用户或进程可以同时访问同一个文件。
- 文件保护：防止未经授权的访问和修改。
- 共享方式：
  - 同时存取共享：多个用户或进程可以同时访问同一个文件。
  - 接力存取共享：多个用户或进程按顺序访问同一个文件。
- **保护机制**：
  - 访问控制列表（ACL）：定义哪些用户或进程可以访问文件以及访问的权限。
  - 文件加密：对文件内容进行加密，防止未授权访问。

## 文件系统

- **定义**：文件系统是操作系统中用于管理和组织文件和目录的软件。
- **文件系统的功能**：
  - 提供文件的存储、检索、更新和共享功能。
  - 确保文件的安全性和一致性。
  - 提供文件的备份和恢复功能。
- **常见文件系统**：
  - **FAT**：文件分配表文件系统，适用于小型存储设备。
  - **NTFS**：Windows操作系统中的高级文件系统，支持大容量存储设备和高级功能。
  - **ext**：Linux操作系统中的文件系统，如ext2、ext3、ext4。
  - **HFS+**：Mac OS操作系统中的文件系统。

## 文件管理的性能优化

- **定义**：文件管理的性能优化是指通过各种方法提高文件系统的性能。
- **优化方法**：
  - **缓存**：使用缓存来提高文件访问速度。
  - **预读取**：预读取文件数据，减少磁盘 I/O 操作。
  - **写入优化**：优化写入操作，减少磁盘 I/O 操作。
  - **文件系统调整**：调整文件系统的参数，提高性能。

## 文件管理的安全性

- **定义**：文件管理的安全性是指保护文件系统免受恶意攻击和数据泄露。
- **安全措施**：
  - **访问控制**：限制对文件的访问权限。
  - **加密**：对文件内容进行加密。
  - **审计**：记录文件系统的操作，以便进行安全审计。
  - **备份和恢复**：定期备份文件系统，以便在发生故障时恢复数据。

## 文件管理的应用

- **定义**：文件管理的应用是指文件系统在各种场景中的应用。
- **应用场景**：
  - **操作系统**：文件系统是操作系统的重要组成部分。
  - **数据库系统**：文件系统用于存储数据库文件。
  - **网络文件系统**：文件系统用于网络环境中的文件共享。
  - **云存储**：文件系统用于云存储服务中的文件管理。

## 作业管理

### 作业管理概述

作业管理是操作系统对计算机系统中的作业进行管理和调度的过程。作业是一组相关的任务或程序，它们结合在一起以完成用户的需求。作业管理的主要目标是实现资源的合理分配和高效利用，提高系统的吞吐量和响应时间。

## 作业管理的主要任务
- **作业调度**：操作系统根据各种调度算法，决定哪个作业优先执行、如何分配计算资源等。调度算法可以按照优先级、先来先服务、时间片轮转等方式进行。
- **作业分配**：操作系统根据系统资源的使用情况和作业的需求，将作业分配给合适的处理器或计算机节点进行执行。作业分配可以按照负载均衡的原则进行，以确保系统资源的充分利用。
- **作业控制**：操作系统对作业的执行进行监控和控制，确保作业按照预期方式执行。包括对作业的启动、暂停、恢复、中止等操作。
- **作业管理**：操作系统对作业的状态、进度、资源占用等进行管理和记录，以便用户和系统管理员了解作业的情况。可以通过作业管理系统提供的接口进行作业信息的查询和操作。

## 作业状态

作业状态分为 4 种：提交、后备、执行和完成。
- **提交**：作业被提交给计算机中心，通过输入设备送入计算机系统的过程状态。
- **后备**：作业通过 Spooling 系统输入到计算机系统的后备存储器（磁盘）中，等待作业调度程序调度的状态。
- **执行**：作业被作业调度程序选中，为其分配必要的资源并建立相应的进程后，进入执行状态。
- **完成**：作业正常结束或异常终止时进入的状态。作业调度程序对该作业进行善后处理。

## 作业调度算法

- **先来先服务**：按作业到达的先后进行调度，启动等待时间最长的作业。
- **短作业优先**：以要求运行时间的长短进行调度，启动要求运行时间最短的作业。
- **响应比高优先**：响应比高的作业优先启动。
- **优先级度算法**：用户可以指定作业优先级，优先级高的作业先启动；也可以根据作业紧迫程度、IO 繁忙情况等由系统指定优先级。
- **均调度算法**：根据系统的运行情况和作业的特性对作业进行分类，调度程序轮流选取不同类别的作业执行，力求均衡利用系统资源。

## 作业的优先级调度

- **定义**：作业的优先级是指作业在调度时的优先程度。
- **优先级的确定**：优先级可以由用户指定，也可以由系统根据作业的紧迫程度、资源需求等因素动态确定。
- **优先级调度算法**：优先级高的作业优先调度，可以提高系统的响应速度和资源利用率。

## 作业的同步与通信

- **作业同步**：当系统中有多个作业并发执行时，操作系统需要确保它们之间的数据共享和互斥访问的正确性。这通常通过使用信号量、互斥锁等机制来实现。
- **作业通信**：操作系统提供一些机制用于不同作业之间的通信和数据交换，如管道、消息队列等。

## 作业完成和回收

- **作业完成**：当作业完成后，操作系统会回收其分配的资源，并将其从系统中移除。
- **作业回收**：操作系统对作业的资源进行回收，包括内存、设备等，以确保系统资源的合理利用。
