## 索引信息（不包含外键约束）统计

其中以 key 或 pkey 结尾大概率为主键索引，idx 开头大概率为普通索引。若 index 加上 UNIQUE 修饰表示唯一。

```sql
CREATE UNIQUE INDEX admin_settings_pkey ON public.admin_settings USING btree (id);
CREATE UNIQUE INDEX alarm_pkey ON public.alarm USING btree (id);
CREATE INDEX idx_alarm_originator_alarm_type ON public.alarm USING btree (originator_id, type, start_ts DESC);
CREATE INDEX idx_alarm_originator_created_time ON public.alarm USING btree (originator_id, created_time DESC);
CREATE INDEX idx_alarm_tenant_alarm_type_created_time ON public.alarm USING btree (tenant_id, type, created_time DESC);

CREATE INDEX idx_alarm_tenant_created_time ON public.alarm USING btree (tenant_id, created_time DESC);
CREATE INDEX idx_alarm_tenant_status_created_time ON public.alarm USING btree (tenant_id, status, created_time DESC);
CREATE UNIQUE INDEX api_usage_state_unq_key ON public.api_usage_state USING btree (tenant_id, entity_id);
CREATE UNIQUE INDEX usage_record_pkey ON public.api_usage_state USING btree (id);
CREATE UNIQUE INDEX asset_name_unq_key ON public.asset USING btree (tenant_id, name);

CREATE UNIQUE INDEX asset_pkey ON public.asset USING btree (id);
CREATE INDEX idx_asset_customer_id ON public.asset USING btree (tenant_id, customer_id);
CREATE INDEX idx_asset_customer_id_and_type ON public.asset USING btree (tenant_id, customer_id, type);
CREATE INDEX idx_asset_type ON public.asset USING btree (tenant_id, type);
CREATE UNIQUE INDEX attribute_kv_pkey ON public.attribute_kv USING btree (entity_type, entity_id, attribute_type, attribute_key);

CREATE INDEX idx_attribute_kv_by_key_and_last_update_ts ON public.attribute_kv USING btree (entity_id, attribute_key, last_update_ts DESC);
CREATE UNIQUE INDEX audit_log_pkey ON public.audit_log USING btree (id);
CREATE INDEX idx_audit_log_tenant_id_and_created_time ON public.audit_log USING btree (tenant_id, created_time);
CREATE UNIQUE INDEX component_descriptor_clazz_key ON public.component_descriptor USING btree (clazz);
CREATE UNIQUE INDEX component_descriptor_pkey ON public.component_descriptor USING btree (id);

CREATE UNIQUE INDEX customer_pkey ON public.customer USING btree (id);
CREATE UNIQUE INDEX dashboard_pkey ON public.dashboard USING btree (id);
CREATE UNIQUE INDEX device_credentials_device_id_unq_key ON public.device_credentials USING btree (device_id);
CREATE UNIQUE INDEX device_credentials_id_unq_key ON public.device_credentials USING btree (credentials_id);
CREATE UNIQUE INDEX device_credentials_pkey ON public.device_credentials USING btree (id);

CREATE UNIQUE INDEX device_name_unq_key ON public.device USING btree (tenant_id, name);
CREATE UNIQUE INDEX device_pkey ON public.device USING btree (id);
CREATE INDEX idx_device_customer_id ON public.device USING btree (tenant_id, customer_id);
CREATE INDEX idx_device_customer_id_and_type ON public.device USING btree (tenant_id, customer_id, type);
CREATE INDEX idx_device_device_profile_id ON public.device USING btree (tenant_id, device_profile_id);

CREATE INDEX idx_device_type ON public.device USING btree (tenant_id, type);
CREATE UNIQUE INDEX device_profile_name_unq_key ON public.device_profile USING btree (tenant_id, name);
CREATE UNIQUE INDEX device_profile_pkey ON public.device_profile USING btree (id);
CREATE UNIQUE INDEX device_provision_key_unq_key ON public.device_profile USING btree (provision_device_key);
CREATE UNIQUE INDEX edge_event_pkey ON public.edge_event USING btree (id);

CREATE UNIQUE INDEX edge_name_unq_key ON public.edge USING btree (tenant_id, name);
CREATE UNIQUE INDEX edge_pkey ON public.edge USING btree (id);
CREATE UNIQUE INDEX edge_routing_key_unq_key ON public.edge USING btree (routing_key);
CREATE UNIQUE INDEX entity_alarm_pkey ON public.entity_alarm USING btree (entity_id, alarm_id);
CREATE INDEX idx_entity_alarm_alarm_id ON public.entity_alarm USING btree (alarm_id);

CREATE INDEX idx_entity_alarm_created_time ON public.entity_alarm USING btree (tenant_id, entity_id, created_time DESC);
CREATE UNIQUE INDEX entity_view_pkey ON public.entity_view USING btree (id);
CREATE UNIQUE INDEX event_pkey ON public.event USING btree (id);
CREATE UNIQUE INDEX event_unq_key ON public.event USING btree (tenant_id, entity_type, entity_id, event_type, event_uid);
CREATE INDEX idx_event_tenant_entity_type_entity_event_type_created_time_des ON public.event USING btree (tenant_id, entity_type, entity_id, event_type, created_time DESC NULLS LAST) WITH (fillfactor='95');

CREATE INDEX idx_event_ts ON public.event USING btree (ts DESC NULLS LAST) WITH (fillfactor='95');
CREATE INDEX idx_relation_from_id ON public.relation USING btree (relation_type_group, from_type, from_id);
CREATE INDEX idx_relation_to_id ON public.relation USING btree (relation_type_group, to_type, to_id);
CREATE UNIQUE INDEX relation_pkey ON public.relation USING btree (from_id, from_type, relation_type_group, relation_type, to_id, to_type);
CREATE INDEX idx_rpc_tenant_id_device_id ON public.rpc USING btree (tenant_id, device_id);

CREATE UNIQUE INDEX rpc_pkey ON public.rpc USING btree (id);
CREATE UNIQUE INDEX oauth2_client_registration_info_pkey ON public.oauth2_client_registration_info USING btree (id);
CREATE UNIQUE INDEX oauth2_client_registration_pkey ON public.oauth2_client_registration USING btree (id);
CREATE UNIQUE INDEX oauth2_client_registration_template_pkey ON public.oauth2_client_registration_template USING btree (id);
CREATE UNIQUE INDEX oauth2_template_provider_id_unq_key ON public.oauth2_client_registration_template USING btree (provider_id);

CREATE UNIQUE INDEX oauth2_domain_pkey ON public.oauth2_domain USING btree (id);
CREATE UNIQUE INDEX oauth2_domain_unq_key ON public.oauth2_domain USING btree (oauth2_params_id, domain_name, domain_scheme);
CREATE UNIQUE INDEX oauth2_mobile_pkey ON public.oauth2_mobile USING btree (id);
CREATE UNIQUE INDEX oauth2_mobile_unq_key ON public.oauth2_mobile USING btree (oauth2_params_id, pkg_name);
CREATE UNIQUE INDEX oauth2_params_pkey ON public.oauth2_params USING btree (id);

CREATE UNIQUE INDEX oauth2_registration_pkey ON public.oauth2_registration USING btree (id);
CREATE UNIQUE INDEX ota_package_pkey ON public.ota_package USING btree (id);
CREATE UNIQUE INDEX ota_package_tenant_title_version_unq_key ON public.ota_package USING btree (tenant_id, title, version);
CREATE UNIQUE INDEX resource_pkey ON public.resource USING btree (id);
CREATE UNIQUE INDEX resource_unq_key ON public.resource USING btree (tenant_id, resource_type, resource_key);

CREATE UNIQUE INDEX rule_chain_pkey ON public.rule_chain USING btree (id);
CREATE UNIQUE INDEX rule_node_pkey ON public.rule_node USING btree (id);
CREATE UNIQUE INDEX rule_node_state_pkey ON public.rule_node_state USING btree (id);
CREATE UNIQUE INDEX rule_node_state_unq_key ON public.rule_node_state USING btree (rule_node_id, entity_id);
CREATE UNIQUE INDEX tb_schema_settings_pkey ON public.tb_schema_settings USING btree (schema_version);

CREATE UNIQUE INDEX tb_user_email_key ON public.tb_user USING btree (email);
CREATE UNIQUE INDEX tb_user_pkey ON public.tb_user USING btree (id);
CREATE UNIQUE INDEX tenant_pkey ON public.tenant USING btree (id);
CREATE UNIQUE INDEX tenant_profile_name_unq_key ON public.tenant_profile USING btree (name);
CREATE UNIQUE INDEX tenant_profile_pkey ON public.tenant_profile USING btree (id);

CREATE UNIQUE INDEX ts_key_id_pkey ON public.ts_kv_dictionary USING btree (key);
CREATE UNIQUE INDEX ts_kv_dictionary_key_id_key ON public.ts_kv_dictionary USING btree (key_id);
CREATE UNIQUE INDEX ts_kv_2022_04_pkey ON public.ts_kv_2022_04 USING btree (entity_id, key, ts);
CREATE UNIQUE INDEX ts_kv_indefinite_pkey ON public.ts_kv_indefinite USING btree (entity_id, key, ts);
CREATE UNIQUE INDEX ts_kv_latest_pkey ON public.ts_kv_latest USING btree (entity_id, key);

CREATE UNIQUE INDEX ts_kv_pkey ON ONLY public.ts_kv USING btree (entity_id, key, ts);
CREATE UNIQUE INDEX user_credentials_activate_token_key ON public.user_credentials USING btree (activate_token);
CREATE UNIQUE INDEX user_credentials_pkey ON public.user_credentials USING btree (id);
CREATE UNIQUE INDEX user_credentials_reset_token_key ON public.user_credentials USING btree (reset_token);
CREATE UNIQUE INDEX user_credentials_user_id_key ON public.user_credentials USING btree (user_id);

CREATE UNIQUE INDEX widget_type_pkey ON public.widget_type USING btree (id);
CREATE UNIQUE INDEX widgets_bundle_pkey ON public.widgets_bundle USING btree (id);
```

### 序列信息

1 个序列
ts_kv_dictionary 的 key_id 是自增列

```
CREATE SEQUENCE IF NOT EXISTS public.ts_kv_dictionary_key_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1
    OWNED BY ts_kv_dictionary.key_id;

ALTER SEQUENCE public.ts_kv_dictionary_key_id_seq
    OWNER TO postgres;
```

### function 函数

以 PL/pgSQL 写成的函数，共 5 个函数

1. 目前没主动调用
```
CREATE OR REPLACE FUNCTION to_uuid(IN entity_id varchar, OUT uuid_id uuid) AS
$$
BEGIN
    uuid_id := substring(entity_id, 8, 8) || '-' || substring(entity_id, 4, 4) || '-1' || substring(entity_id, 1, 3) ||
               '-' || substring(entity_id, 16, 4) || '-' || substring(entity_id, 20, 12);
END;
$$ LANGUAGE plpgsql;
```

2. cleanup_timeseries_by_ttl 存储过程有用到该函数
```
CREATE OR REPLACE FUNCTION delete_device_records_from_ts_kv(tenant_id uuid, customer_id uuid, ttl bigint,
                                                            OUT deleted bigint) AS
$$
BEGIN
    EXECUTE format(
            'WITH deleted AS (DELETE FROM ts_kv WHERE entity_id IN (SELECT device.id as entity_id FROM device WHERE tenant_id = %L and customer_id = %L) AND ts < %L::bigint RETURNING *) SELECT count(*) FROM deleted',
            tenant_id, customer_id, ttl) into deleted;
END;
$$ LANGUAGE plpgsql;
```

3. cleanup_timeseries_by_ttl 存储过程有用到该函数
```sql
CREATE OR REPLACE FUNCTION delete_asset_records_from_ts_kv(tenant_id uuid, customer_id uuid, ttl bigint,
                                                           OUT deleted bigint) AS
$$
BEGIN
    EXECUTE format(
            'WITH deleted AS (DELETE FROM ts_kv WHERE entity_id IN (SELECT asset.id as entity_id FROM asset WHERE tenant_id = %L and customer_id = %L) AND ts < %L::bigint RETURNING *) SELECT count(*) FROM deleted',
            tenant_id, customer_id, ttl) into deleted;
END;
$$ LANGUAGE plpgsql;
```

4. cleanup_timeseries_by_ttl 存储过程有用到该函数
```
CREATE OR REPLACE FUNCTION delete_customer_records_from_ts_kv(tenant_id uuid, customer_id uuid, ttl bigint,
                                                              OUT deleted bigint) AS
$$
BEGIN
    EXECUTE format(
            'WITH deleted AS (DELETE FROM ts_kv WHERE entity_id IN (SELECT customer.id as entity_id FROM customer WHERE tenant_id = %L and id = %L) AND ts < %L::bigint RETURNING *) SELECT count(*) FROM deleted',
            tenant_id, customer_id, ttl) into deleted;
END;
$$ LANGUAGE plpgsql;
```

5. drop_partitions_by_max_ttl 存储过程有用到该函数
```
CREATE OR REPLACE FUNCTION get_partition_by_max_ttl_date(IN partition_type varchar, IN date timestamp, OUT partition varchar) AS
$$
BEGIN
    CASE
        WHEN partition_type = 'DAYS' THEN
            partition := 'ts_kv_' || to_char(date, 'yyyy') || '_' || to_char(date, 'MM') || '_' || to_char(date, 'dd');
        WHEN partition_type = 'MONTHS' THEN
            partition := 'ts_kv_' || to_char(date, 'yyyy') || '_' || to_char(date, 'MM');
        WHEN partition_type = 'YEARS' THEN
            partition := 'ts_kv_' || to_char(date, 'yyyy');
        ELSE
            partition := NULL;
        END CASE;
    IF partition IS NOT NULL THEN
        IF NOT EXISTS(SELECT
                      FROM pg_tables
                      WHERE schemaname = 'public'
                        AND tablename = partition) THEN
            partition := NULL;
            RAISE NOTICE 'Failed to found partition by ttl';
        END IF;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 存储过程

5 个存储过程

1. cleanup_edge_events_by_ttl
```
CREATE OR REPLACE PROCEDURE cleanup_edge_events_by_ttl(IN ttl bigint, INOUT deleted bigint)
    LANGUAGE plpgsql AS
$$
DECLARE
    ttl_ts bigint;
    ttl_deleted_count bigint DEFAULT 0;
BEGIN
    IF ttl > 0 THEN
        ttl_ts := (EXTRACT(EPOCH FROM current_timestamp) * 1000 - ttl::bigint * 1000)::bigint;
        EXECUTE format(
                'WITH deleted AS (DELETE FROM edge_event WHERE ts < %L::bigint RETURNING *) SELECT count(*) FROM deleted', ttl_ts) into ttl_deleted_count;
    END IF;
    RAISE NOTICE 'Edge events removed by ttl: %', ttl_deleted_count;
    deleted := ttl_deleted_count;
END
$$;
```

2. cleanup_events_by_ttl
```
CREATE OR REPLACE PROCEDURE cleanup_events_by_ttl(
    IN regular_events_start_ts bigint,
    IN regular_events_end_ts bigint,
    IN debug_events_start_ts bigint,
    IN debug_events_end_ts bigint,
    INOUT deleted bigint)
    LANGUAGE plpgsql AS
$$
DECLARE
    ttl_deleted_count bigint DEFAULT 0;
    debug_ttl_deleted_count bigint DEFAULT 0;
BEGIN
    IF regular_events_start_ts > 0 AND regular_events_end_ts > 0 THEN
        EXECUTE format(
                'WITH deleted AS (DELETE FROM event WHERE id in (SELECT id from event WHERE ts > %L::bigint AND ts < %L::bigint AND ' ||
                '(event_type != %L::varchar AND event_type != %L::varchar)) RETURNING *) ' ||
                'SELECT count(*) FROM deleted', regular_events_start_ts, regular_events_end_ts,
                'DEBUG_RULE_NODE', 'DEBUG_RULE_CHAIN') into ttl_deleted_count;
    END IF;
    IF debug_events_start_ts > 0 AND debug_events_end_ts > 0 THEN
        EXECUTE format(
                'WITH deleted AS (DELETE FROM event WHERE id in (SELECT id from event WHERE ts > %L::bigint AND ts < %L::bigint AND ' ||
                '(event_type = %L::varchar OR event_type = %L::varchar)) RETURNING *) ' ||
                'SELECT count(*) FROM deleted', debug_events_start_ts, debug_events_end_ts,
                'DEBUG_RULE_NODE', 'DEBUG_RULE_CHAIN') into debug_ttl_deleted_count;
    END IF;
    RAISE NOTICE 'Events removed by ttl: %', ttl_deleted_count;
    RAISE NOTICE 'Debug Events removed by ttl: %', debug_ttl_deleted_count;
    deleted := ttl_deleted_count + debug_ttl_deleted_count;
END
$$;
```

3. cleanup_timeseries_by_ttl
```
CREATE OR REPLACE PROCEDURE cleanup_timeseries_by_ttl(IN null_uuid uuid,
                                                      IN system_ttl bigint, INOUT deleted bigint)
    LANGUAGE plpgsql AS
$$
DECLARE
    tenant_cursor CURSOR FOR select tenant.id as tenant_id
                             from tenant;
    tenant_id_record     uuid;
    customer_id_record   uuid;
    tenant_ttl           bigint;
    customer_ttl         bigint;
    deleted_for_entities bigint;
    tenant_ttl_ts        bigint;
    customer_ttl_ts      bigint;
BEGIN
    OPEN tenant_cursor;
    FETCH tenant_cursor INTO tenant_id_record;
    WHILE FOUND
        LOOP
            EXECUTE format(
                    'select attribute_kv.long_v from attribute_kv where attribute_kv.entity_id = %L and attribute_kv.attribute_key = %L',
                    tenant_id_record, 'TTL') INTO tenant_ttl;
            if tenant_ttl IS NULL THEN
                tenant_ttl := system_ttl;
            END IF;
            IF tenant_ttl > 0 THEN
                tenant_ttl_ts := (EXTRACT(EPOCH FROM current_timestamp) * 1000 - tenant_ttl::bigint * 1000)::bigint;
                deleted_for_entities := delete_device_records_from_ts_kv(tenant_id_record, null_uuid, tenant_ttl_ts);
                deleted := deleted + deleted_for_entities;
                RAISE NOTICE '% telemetry removed for devices where tenant_id = %', deleted_for_entities, tenant_id_record;
                deleted_for_entities := delete_asset_records_from_ts_kv(tenant_id_record, null_uuid, tenant_ttl_ts);
                deleted := deleted + deleted_for_entities;
                RAISE NOTICE '% telemetry removed for assets where tenant_id = %', deleted_for_entities, tenant_id_record;
            END IF;
            FOR customer_id_record IN
                SELECT customer.id AS customer_id FROM customer WHERE customer.tenant_id = tenant_id_record
                LOOP
                    EXECUTE format(
                            'select attribute_kv.long_v from attribute_kv where attribute_kv.entity_id = %L and attribute_kv.attribute_key = %L',
                            customer_id_record, 'TTL') INTO customer_ttl;
                    IF customer_ttl IS NULL THEN
                        customer_ttl_ts := tenant_ttl_ts;
                    ELSE
                        IF customer_ttl > 0 THEN
                            customer_ttl_ts :=
                                    (EXTRACT(EPOCH FROM current_timestamp) * 1000 -
                                     customer_ttl::bigint * 1000)::bigint;
                        END IF;
                    END IF;
                    IF customer_ttl_ts IS NOT NULL AND customer_ttl_ts > 0 THEN
                        deleted_for_entities :=
                                delete_customer_records_from_ts_kv(tenant_id_record, customer_id_record,
                                                                   customer_ttl_ts);
                        deleted := deleted + deleted_for_entities;
                        RAISE NOTICE '% telemetry removed for customer with id = % where tenant_id = %', deleted_for_entities, customer_id_record, tenant_id_record;
                        deleted_for_entities :=
                                delete_device_records_from_ts_kv(tenant_id_record, customer_id_record,
                                                                 customer_ttl_ts);
                        deleted := deleted + deleted_for_entities;
                        RAISE NOTICE '% telemetry removed for devices where tenant_id = % and customer_id = %', deleted_for_entities, tenant_id_record, customer_id_record;
                        deleted_for_entities := delete_asset_records_from_ts_kv(tenant_id_record,
                                                                                customer_id_record,
                                                                                customer_ttl_ts);
                        deleted := deleted + deleted_for_entities;
                        RAISE NOTICE '% telemetry removed for assets where tenant_id = % and customer_id = %', deleted_for_entities, tenant_id_record, customer_id_record;
                    END IF;
                END LOOP;
            FETCH tenant_cursor INTO tenant_id_record;
        END LOOP;
END
$$;
```

4. drop_partitions_by_max_ttl
```
CREATE OR REPLACE PROCEDURE drop_partitions_by_max_ttl(IN partition_type varchar, IN system_ttl bigint, INOUT deleted bigint)
    LANGUAGE plpgsql AS
$$
DECLARE
    max_tenant_ttl             bigint;
    max_customer_ttl           bigint;
    max_ttl                    bigint;
    date                       timestamp;
    partition_by_max_ttl_date  varchar;
    partition_by_max_ttl_month varchar;
    partition_by_max_ttl_day   varchar;
    partition_by_max_ttl_year  varchar;
    partition                  varchar;
    partition_year             integer;
    partition_month            integer;
    partition_day              integer;
BEGIN
    SELECT max(attribute_kv.long_v)
    FROM tenant
             INNER JOIN attribute_kv ON tenant.id = attribute_kv.entity_id
    WHERE attribute_kv.attribute_key = 'TTL'
    into max_tenant_ttl;
    SELECT max(attribute_kv.long_v)
    FROM customer
             INNER JOIN attribute_kv ON customer.id = attribute_kv.entity_id
    WHERE attribute_kv.attribute_key = 'TTL'
    into max_customer_ttl;
    max_ttl := GREATEST(system_ttl, max_customer_ttl, max_tenant_ttl);
    if max_ttl IS NOT NULL AND max_ttl > 0 THEN
        date := to_timestamp(EXTRACT(EPOCH FROM current_timestamp) - max_ttl);
        partition_by_max_ttl_date := get_partition_by_max_ttl_date(partition_type, date);
        RAISE NOTICE 'Date by max ttl: %', date;
        RAISE NOTICE 'Partition by max ttl: %', partition_by_max_ttl_date;
        IF partition_by_max_ttl_date IS NOT NULL THEN
            CASE
                WHEN partition_type = 'DAYS' THEN
                    partition_by_max_ttl_year := SPLIT_PART(partition_by_max_ttl_date, '_', 3);
                    partition_by_max_ttl_month := SPLIT_PART(partition_by_max_ttl_date, '_', 4);
                    partition_by_max_ttl_day := SPLIT_PART(partition_by_max_ttl_date, '_', 5);
                WHEN partition_type = 'MONTHS' THEN
                    partition_by_max_ttl_year := SPLIT_PART(partition_by_max_ttl_date, '_', 3);
                    partition_by_max_ttl_month := SPLIT_PART(partition_by_max_ttl_date, '_', 4);
                ELSE
                    partition_by_max_ttl_year := SPLIT_PART(partition_by_max_ttl_date, '_', 3);
                END CASE;
            IF partition_by_max_ttl_year IS NULL THEN
                RAISE NOTICE 'Failed to remove partitions by max ttl date due to partition_by_max_ttl_year is null!';
            ELSE
                IF partition_type = 'YEARS' THEN
                    FOR partition IN SELECT tablename
                                     FROM pg_tables
                                     WHERE schemaname = 'public'
                                       AND tablename like 'ts_kv_' || '%'
                                       AND tablename != 'ts_kv_latest'
                                       AND tablename != 'ts_kv_dictionary'
                                       AND tablename != 'ts_kv_indefinite'
                                       AND tablename != partition_by_max_ttl_date
                        LOOP
                            partition_year := SPLIT_PART(partition, '_', 3)::integer;
                            IF partition_year < partition_by_max_ttl_year::integer THEN
                                RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                deleted := deleted + 1;
                            END IF;
                        END LOOP;
                ELSE
                    IF partition_type = 'MONTHS' THEN
                        IF partition_by_max_ttl_month IS NULL THEN
                            RAISE NOTICE 'Failed to remove months partitions by max ttl date due to partition_by_max_ttl_month is null!';
                        ELSE
                            FOR partition IN SELECT tablename
                                             FROM pg_tables
                                             WHERE schemaname = 'public'
                                               AND tablename like 'ts_kv_' || '%'
                                               AND tablename != 'ts_kv_latest'
                                               AND tablename != 'ts_kv_dictionary'
                                               AND tablename != 'ts_kv_indefinite'
                                               AND tablename != partition_by_max_ttl_date
                                LOOP
                                    partition_year := SPLIT_PART(partition, '_', 3)::integer;
                                    IF partition_year > partition_by_max_ttl_year::integer THEN
                                        RAISE NOTICE 'Skip iteration! Partition: % is valid!', partition;
                                        CONTINUE;
                                    ELSE
                                        IF partition_year < partition_by_max_ttl_year::integer THEN
                                            RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                            EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                            deleted := deleted + 1;
                                        ELSE
                                            partition_month := SPLIT_PART(partition, '_', 4)::integer;
                                            IF partition_year = partition_by_max_ttl_year::integer THEN
                                               IF  partition_month >= partition_by_max_ttl_month::integer THEN
                                                   RAISE NOTICE 'Skip iteration! Partition: % is valid!', partition;
                                                   CONTINUE;
                                               ELSE
                                                   RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                                   EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                                   deleted := deleted + 1;
                                               END IF;
                                            END IF;
                                        END IF;
                                    END IF;
                                END LOOP;
                        END IF;
                    ELSE
                        IF partition_type = 'DAYS' THEN
                            IF partition_by_max_ttl_month IS NULL THEN
                                RAISE NOTICE 'Failed to remove days partitions by max ttl date due to partition_by_max_ttl_month is null!';
                            ELSE
                                IF partition_by_max_ttl_day IS NULL THEN
                                    RAISE NOTICE 'Failed to remove days partitions by max ttl date due to partition_by_max_ttl_day is null!';
                                ELSE
                                    FOR partition IN SELECT tablename
                                                     FROM pg_tables
                                                     WHERE schemaname = 'public'
                                                       AND tablename like 'ts_kv_' || '%'
                                                       AND tablename != 'ts_kv_latest'
                                                       AND tablename != 'ts_kv_dictionary'
                                                       AND tablename != 'ts_kv_indefinite'
                                                       AND tablename != partition_by_max_ttl_date
                                        LOOP
                                            partition_year := SPLIT_PART(partition, '_', 3)::integer;
                                            IF partition_year > partition_by_max_ttl_year::integer THEN
                                                RAISE NOTICE 'Skip iteration! Partition: % is valid!', partition;
                                                CONTINUE;
                                            ELSE
                                                IF partition_year < partition_by_max_ttl_year::integer THEN
                                                    RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                                    EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                                    deleted := deleted + 1;
                                                ELSE
                                                    partition_month := SPLIT_PART(partition, '_', 4)::integer;
                                                    IF partition_month > partition_by_max_ttl_month::integer THEN
                                                        RAISE NOTICE 'Skip iteration! Partition: % is valid!', partition;
                                                        CONTINUE;
                                                    ELSE
                                                        IF partition_month < partition_by_max_ttl_month::integer THEN
                                                            RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                                            EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                                            deleted := deleted + 1;
                                                        ELSE
                                                            partition_day := SPLIT_PART(partition, '_', 5)::integer;
                                                            IF partition_day >= partition_by_max_ttl_day::integer THEN
                                                                RAISE NOTICE 'Skip iteration! Partition: % is valid!', partition;
                                                                CONTINUE;
                                                            ELSE
                                                                IF partition_day < partition_by_max_ttl_day::integer THEN
                                                                    RAISE NOTICE 'Partition to delete by max ttl: %', partition;
                                                                    EXECUTE format('DROP TABLE IF EXISTS %I', partition);
                                                                    deleted := deleted + 1;
                                                                END IF;
                                                            END IF;
                                                        END IF;
                                                    END IF;
                                                END IF;
                                            END IF;
                                        END LOOP;
                                END IF;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;
END
$$;
```

5. insert_tb_schema_settings
```sql
CREATE OR REPLACE PROCEDURE insert_tb_schema_settings()
    LANGUAGE plpgsql AS
$$
BEGIN
    IF (SELECT COUNT(*) FROM tb_schema_settings) = 0 THEN
        INSERT INTO tb_schema_settings (schema_version) VALUES (3003000);
    END IF;
END;
$$;
```

存储过程的调用
call insert_tb_schema_settings();

## 功能划分

### 数据模型之用户相关表结构设计

![](https://upload-images.jianshu.io/upload_images/1662509-faf827a38d0b6e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### tenant 租户表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | varchar(31) | 租户编号 |
| created_time | bigint | 创建时间 |
| additional_info | varchar | 额外信息 |
| address | varchar | 第一地址 |
| address2 | varchar(255) | 第二地址 |
| city | varchar(255) | 城市 |
| country | varchar(255) | 国家 |
| email | varchar(255) | 邮箱 |
| phone | varchar(255) | 电话号码 |
| region | varchar(255) | 区域 |
| search_text | varchar(255) | 搜索关键字 |
| state | varchar(255) | 省份 |
| title | varchar(255) | 租户名称 |
| zip | varchar(255) | 邮政编码 |
| isolated_tb_core | boolean | 单独tb容器服务 |
| isolated_tb_rule_engine | boolean | 单独tb规则引擎服务 |

数据
| id | created_time | additional_info | address | address2 | city | country | email | phone | region | search_text | state | title | zip | isolated_tb_core | isolated_tb_rule_engine |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| e102f1b0-fcb8-11ea-82f8-9b35f0369853 | 1600768156747 | {"description":"测试租户相关的数据库字段"} | 杭州西湖区 | 杭州余杭区 | HangZhou | China | [lovewsic@gmail.com](mailto:lovewsic@gmail.com) | 18036142209 | Global | 租户测试 | ZheJiang | 租户测试 | 310000 | true | `true` |

#### customer 客户表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 客户编号 |
| created_time | bigint | 创建时间 |
| additional_info | varchar | 额外信息 |
| address | varchar | 第一地址 |
| address2 | varchar | 第二地址 |
| city | varchar(255) | 城市 |
| country | varchar(255) | 国家 |
| email | varchar(255) | 邮箱 |
| phone | varchar(255) | 电话号码 |
| search_text | varchar(255) | 搜索关键字 |
| state | varchar(255) | 省份 |
| tenant_id | uuid | 租户编号 |
| title | varchar(255) | 客户名称 |
| zip | varchar(255) | 邮政编码 |

数据
| id | created_time | additional_info | address | address2 | city | country | email | phone | search_text | state | tenant_id | title | zip |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 49b23e10-fd3a-11ea-bd9b-65a3fbb30788 | 1600823737457 | {"description":"Customer A"} | 杭州西湖区 | 杭州余杭区 | HangZhou | China |  | 18036142209 | 租户测试-customer a | 浙江 | e102f1b0-fcb8-11ea-82f8-9b35f0369853 | 租户测试-Customer A | 310000 |

#### tb_user 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 用户编号 |
| created_time | bigint | 创建时间 |
| additional_info | varchar | 额外信息 |
| authority | varchar(255) | 权限 |
| customer_id | uuid | 客户编号 |
| email | varchar(255) | 邮箱 |
| first_name | varchar(255) | 姓 |
| last_name | varchar(255) | 名 |
| search_text | varchar(255) | 搜索关键字 |
| tenant_id | uuid | 租户编号 |

数据
| id | created_time | additional_info | authority | customer_id | email | first_name | last_name | search_text | tenant_id |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| d96bfe60-e881-11ea-a452-0bb049e7ba49 | 1598545498438 | {"userPasswordHistory":{"1598545498857":"$2a$10$DGTJezh/ctB/NYK0JrxhyuFe7IxnCLlnb6x8/mezr8wFU5WT.vvyK"},"lastLoginTs":1600823576876,"failedLoginAttempts":0} | SYS_ADMIN | 13814000-1dd2-11b2-8080-808080808080 | [sysadmin@thingsboard.org](mailto:sysadmin@thingsboard.org) |  |  | [sysadmin@thingsboard.org](mailto:sysadmin@thingsboard.org) | 13814000-1dd2-11b2-8080-808080808080 |
| bfd211c0-fd39-11ea-bd9b-65a3fbb30788 | 1600823506140 | {"description":"admin manager","defaultDashboardId":null,"defaultDashboardFullscreen":false,"userPasswordHistory":{"1600823540675":"$2a$10$FgfcK3tItxsyxLjd1uiAze0smb4srCbf4Kbx6EIXez16F/GOMqsSq"},"lastLoginTs":1600823673157,"failedLoginAttempts":0} | TENANT_ADMIN | 13814000-1dd2-11b2-8080-808080808080 | [lovewsic@gmail.com](mailto:lovewsic@gmail.com) | 书伟 | 穆 | [lovewsic@gmail.com](mailto:lovewsic@gmail.com) | e102f1b0-fcb8-11ea-82f8-9b35f0369853 |

#### user_credentials 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 用户认证编号 |
| created_time | bigint | 创建时间 |
| activate_token | varchar(255) | 激活令牌 |
| enabled | boolean | 是否开启 |
| password | varchar(255) | 密码 |
| reset_token | varchar(255) | 重置令牌 |
| user_id | uuid | 用户编号 |

数据
| id | created_time | activate_token | enabled | password | reset_token | user_id |
| --- | --- | --- | --- | --- | --- | --- |
| d9924b10-e881-11ea-a452-0bb049e7ba49 | 1598545498689 |  | true | $2a$10$DGTJezh/ctB/NYK0JrxhyuFe7IxnCLlnb6x8/mezr8wFU5WT.vvyK |  | d96bfe60-e881-11ea-a452-0bb049e7ba49 |
| bfe0b7c0-fd39-11ea-bd9b-65a3fbb30788 | 1600823506236 |  | true | $2a$10$FgfcK3tItxsyxLjd1uiAze0smb4srCbf4Kbx6EIXez16F/GOMqsSq |  | bfd211c0-fd39-11ea-bd9b-65a3fbb30788 |

#### admin_settings 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 系统设置编号 |
| created_time | bigint | 创建时间 |
| json_value | varchar | 系统设置JSON字符串 |
| key | varchar(255) | 设置关键字 |

数据
| id | created_time | json_value | key |
| --- | --- | --- | --- |
| d9af48f0-e881-11ea-a452-0bb049e7ba49 | 1598545498879 | {"baseUrl":"[http://localhost:8080"}](http://localhost:8080"}/) | general |
| d9b25630-e881-11ea-a452-0bb049e7ba49 | 1598545498899 | {"mailFrom":"ThingsBoard [sysadmin@localhost.localdomain](mailto:sysadmin@localhost.localdomain)","smtpProtocol":"smtp","smtpHost":"localhost","smtpPort":"25","timeout":"10000","enableTls":false,"username":"","password":"","tlsVersion":"TLSv1.2","enableProxy":false} | mail |

#### tb_schema_settings 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| schema_version | bigint | 数据模式版本 |

数据
| schema_version |
| --- |
| 3001000 |

#### widget_type 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id |  |  |
| created_time |  |  |
| alias |  |  |
| bundle_alias |  |  |
| descriptor |  |  |
| name |  |  |
| tenant_id |  |  |

数据
| id | created_time | alias | bundle_alias | descriptor | name | tenant_id |
| --- | --- | --- | --- | --- | --- | --- |
| da4631c0-e881-11ea-a452-0bb049e7ba49 | 1598545499868 | raspberry_pi_gpio_panel | gpio_widgets | {"type":"latest","sizeX":7,"sizeY":10.5,"resources":[],"templateHtml":"<div class="gpio-panel" style="height: 100%;">\n <section fxLayout="row" *ngFor="let row of rows">\n <section fxFlex fxLayout="row" *ngFor="let cell of row; let $index = index">\n <section fxLayout="row" fxFlex *ngIf="cell" fxLayoutAlign="{{$index===0 ? 'end center' : 'start center'}}">\n <span class="gpio-left-label" [fxShow]="$index===0">{{ cell.label }}\n <section fxLayout="row" class="led-panel" [ngClass]="$index===0 ? 'col-0' : 'col-1'"\n [ngStyle]="{backgroundColor: ledPanelBackgroundColor}">\n <span class="pin" [fxShow]="$index===0">{{cell.pin}}\n <span class="led-container">\n <tb-led-light [size]="prefferedRowHeight"\n [colorOn]="cell.colorOn"\n [colorOff]="cell.colorOff"\n [offOpacity]="'0.9'"\n [enabled]="cell.enabled">\n \n \n <span class="pin" [fxShow]="$index===1">{{cell.pin}}\n \n <span class="gpio-right-label" [fxShow]="$index===1">{{ cell.label }}\n \n <section fxLayout="row" fxFlex *ngIf="!cell">\n <span fxFlex [fxShow]="$index===0">\n <span class="led-panel"\n [ngStyle]="{backgroundColor: ledPanelBackgroundColor}">\n <span fxFlex [fxShow]="$index===1">\n \n \n \n","templateCss":".error {\n font-size: 14px !important;\n color: maroon;/*rgb(250,250,250);*/\n background-color: transparent;\n padding: 6px;\n}\n\n.error span {\n margin: auto;\n}\n\n.gpio-panel {\n padding-top: 10px;\n white-space: nowrap;\n}\n\n.gpio-panel section[fxflex] {\n min-width: 0px;\n}\n\n.gpio-panel tb-led-light > div {\n margin: auto;\n}\n\n.led-panel {\n margin: 0;\n width: 66px;\n min-width: 66px;\n}\n\n.led-container {\n width: 48px;\n min-width: 48px;\n}\n\n.pin {\n margin-top: auto;\n margin-bottom: auto;\n color: white;\n font-size: 12px;\n width: 16px;\n min-width: 16px;\n}\n\n.led-panel.col-0 .pin {\n margin-left: auto;\n padding-left: 2px;\n text-align: right;\n}\n\n.led-panel.col-1 .pin {\n margin-right: auto;\n \n text-align: left;\n}\n\n.gpio-left-label {\n margin-right: 8px;\n}\n\n.gpio-right-label {\n margin-left: 8px;\n}","controllerScript":"var namespace;\nvar cssParser = new cssjs();\n\nself.onInit = function() {\n var utils = self.ctx.$injector.get(self.ctx.servicesMap.get('utils'));\n namespace = 'gpio-panel-' + utils.guid();\n cssParser.testMode = false;\n cssParser.cssPreviewNamespace = namespace;\n self.ctx.$container.addClass(namespace);\n self.ctx.ngZone.run(function() {\n init(); \n });\n}\n\nfunction init() {\n var i, gpio;\n \n var scope = self.ctx.$scope;\n var settings = self.ctx.settings;\n \n scope.gpioList = [];\n scope.gpioByPin = {};\n for (var g = 0; g < settings.gpioList.length; g++) {\n gpio = settings.gpioList[g];\n scope.gpioList.push(\n {\n row: gpio.row,\n col: gpio.col,\n pin: gpio.pin,\n label: gpio.label,\n enabled: false,\n colorOn: tinycolor(gpio.color).lighten(20).toHexString(),\n colorOff: tinycolor(gpio.color).darken().toHexString()\n }\n );\n scope.gpioByPin[gpio.pin] = scope.gpioList[scope.gpioList.length-1];\n }\n\n scope.ledPanelBackgroundColor = settings.ledPanelBackgroundColor || tinycolor('green').lighten(2).toRgbString();\n\n scope.gpioCells = {};\n var rowCount = 0;\n for (i = 0; i < scope.gpioList.length; i++) {\n gpio = scope.gpioList[i];\n scope.gpioCells[gpio.row+'_'+gpio.col] = gpio;\n rowCount = Math.max(rowCount, gpio.row+1);\n }\n \n scope.prefferedRowHeight = 32;\n scope.rows = [];\n for (i = 0; i < rowCount; i++) {\n var row = [];\n for (var c =0; c<2;c++) {\n if (scope.gpioCells[i+'_'+c]) {\n row[c] = scope.gpioCells[i+'_'+c];\n } else {\n row[c] = null;\n }\n }\n scope.rows.push(row);\n } \n \n self.onResize();\n}\n\nself.onDataUpdated = function() {\n var changed = false;\n for (var d = 0; d < self.ctx.data.length; d++) {\n var cellData = self.ctx.data[d];\n var dataKey = cellData.dataKey;\n var gpio = self.ctx.$scope.gpioByPin[dataKey.label];\n if (gpio) {\n var enabled = false;\n if (cellData.data.length > 0) {\n var tvPair = cellData.data[cellData.data.length - 1];\n enabled = (tvPair[1] === true || tvPair[1] === 'true');\n }\n if (gpio.enabled != enabled) {\n changed = true;\n gpio.enabled = enabled;\n }\n }\n }\n if (changed) {\n self.ctx.detectChanges();\n } \n}\n\nself.onResize = function() {\n var rowCount = self.ctx.$scope.rows.length;\n var prefferedRowHeight = (self.ctx.height - 35)/rowCount;\n prefferedRowHeight = Math.min(32, prefferedRowHeight);\n prefferedRowHeight = Math.max(12, prefferedRowHeight);\n self.ctx.$scope.prefferedRowHeight = prefferedRowHeight;\n \n var ratio = prefferedRowHeight/32;\n \n var css = '.gpio-left-label, .gpio-right-label {\n' +\n ' font-size: ' + 16*ratio+'px;\n'+\n '}\n';\n var pinsFontSize = Math.max(9, 12*ratio);\n css += '.pin {\n' +\n ' font-size: ' + pinsFontSize+'px;\n'+\n '}\n';\n \n cssParser.createStyleElement(namespace, css); \n \n self.ctx.detectChanges();\n}\n\nself.onDestroy = function() {\n}\n","settingsSchema":"{\n "schema": {\n "type": "object",\n "title": "Settings",\n "properties": {\n "gpioList": {\n "title": "Gpio leds",\n "type": "array",\n "minItems" : 1,\n "items": {\n "title": "Gpio led",\n "type": "object",\n "properties": {\n "pin": {\n "title": "Pin",\n "type": "number"\n },\n "label": {\n "title": "Label",\n "type": "string"\n },\n "row": {\n "title": "Row",\n "type": "number"\n },\n "col": {\n "title": "Column",\n "type": "number"\n },\n "color": {\n "title": "Color",\n "type": "string",\n "default": "red"\n }\n },\n "required": ["pin", "label", "row", "col", "color"]\n }\n },\n "ledPanelBackgroundColor": {\n "title": "LED panel background color",\n "type": "string",\n "default": "#008a00"\n } \n },\n "required": ["gpioList", \n "ledPanelBackgroundColor"]\n },\n "form": [\n {\n "key": "gpioList",\n "items": [\n "gpioList[].pin",\n "gpioList[].label",\n "gpioList[].row",\n "gpioList[].col",\n {\n "key": "gpioList[].color",\n "type": "color"\n }\n ]\n },\n {\n "key": "ledPanelBackgroundColor",\n "type": "color"\n }\n ]\n}","dataKeySettingsSchema":"{}\n","defaultConfig":"{"showTitle":true,"backgroundColor":"#fff","color":"rgba(0, 0, 0, 0.87)","padding":"0px","settings":{"gpioList":[{"pin":1,"label":"3.3V","row":0,"col":0,"color":"#fc9700","_uniqueKey":0},{"pin":2,"label":"5V","row":0,"col":1,"color":"#fb0000","_uniqueKey":1},{"pin":3,"label":"GPIO 2 (I2C1_SDA)","row":1,"col":0,"color":"#02fefb","_uniqueKey":2},{"color":"#fb0000","pin":4,"label":"5V","row":1,"col":1},{"color":"#02fefb","pin":5,"label":"GPIO 3 (I2C1_SCL)","row":2,"col":0},{"color":"#000000","pin":6,"label":"GND","row":2,"col":1},{"color":"#00fd00","pin":7,"label":"GPIO 4 (GPCLK0)","row":3,"col":0},{"color":"#fdfb00","pin":8,"label":"GPIO 14 (UART_TXD)","row":3,"col":1},{"color":"#000000","pin":9,"label":"GND","row":4,"col":0},{"color":"#fdfb00","pin":10,"label":"GPIO 15 (UART_RXD)","row":4,"col":1},{"color":"#00fd00","pin":11,"label":"GPIO 17","row":5,"col":0},{"color":"#00fd00","pin":12,"label":"GPIO 18","row":5,"col":1},{"color":"#00fd00","pin":13,"label":"GPIO 27","row":6,"col":0},{"color":"#000000","pin":14,"label":"GND","row":6,"col":1},{"color":"#00fd00","pin":15,"label":"GPIO 22","row":7,"col":0},{"color":"#00fd00","pin":16,"label":"GPIO 23","row":7,"col":1},{"color":"#fc9700","pin":17,"label":"3.3V","row":8,"col":0},{"color":"#00fd00","pin":18,"label":"GPIO 24","row":8,"col":1},{"color":"#fd01fd","pin":19,"label":"GPIO 10 (SPI_MOSI)","row":9,"col":0},{"color":"#000000","pin":20,"label":"GND","row":9,"col":1},{"color":"#fd01fd","pin":21,"label":"GPIO 9 (SPI_MISO)","row":10,"col":0},{"color":"#00fd00","pin":22,"label":"GPIO 25","row":10,"col":1},{"color":"#fd01fd","pin":23,"label":"GPIO 11 (SPI_SCLK)","row":11,"col":0},{"color":"#fd01fd","pin":24,"label":"GPIO 8 (SPI_CE0)","row":11,"col":1},{"color":"#000000","pin":25,"label":"GND","row":12,"col":0},{"color":"#fd01fd","pin":26,"label":"GPIO 7 (SPI_CE1)","row":12,"col":1},{"color":"#ffffff","pin":27,"label":"ID_SD","row":13,"col":0},{"color":"#ffffff","pin":28,"label":"ID_SC","row":13,"col":1},{"color":"#00fd00","pin":29,"label":"GPIO 5","row":14,"col":0},{"color":"#000000","pin":30,"label":"GND","row":14,"col":1},{"color":"#00fd00","pin":31,"label":"GPIO 6","row":15,"col":0},{"color":"#00fd00","pin":32,"label":"GPIO 12","row":15,"col":1},{"color":"#00fd00","pin":33,"label":"GPIO 13","row":16,"col":0},{"color":"#000000","pin":34,"label":"GND","row":16,"col":1},{"color":"#00fd00","pin":35,"label":"GPIO 19","row":17,"col":0},{"color":"#00fd00","pin":36,"label":"GPIO 16","row":17,"col":1},{"color":"#00fd00","pin":37,"label":"GPIO 26","row":18,"col":0},{"color":"#00fd00","pin":38,"label":"GPIO 20","row":18,"col":1},{"color":"#000000","pin":39,"label":"GND","row":19,"col":0},{"color":"#00fd00","pin":40,"label":"GPIO 21","row":19,"col":1}],"ledPanelBackgroundColor":"#008a00"},"title":"Raspberry Pi GPIO Panel","datasources":[{"type":"function","name":"function","dataKeys":[{"name":"f(x)","type":"function","label":"7","color":"#2196f3","settings":{},"_hash":0.22518255793320163,"funcBody":"var period = time % 1500;\nreturn period < 500;"},{"name":"f(x)","type":"function","label":"11","color":"#4caf50","settings":{},"_hash":0.7008206860666621,"funcBody":"var period = time % 1500;\nreturn period >= 500 && period < 1000;"},{"name":"f(x)","type":"function","label":"12","color":"#f44336","settings":{},"_hash":0.42600325102193426,"funcBody":"var period = time % 1500;\nreturn period >= 1000;"},{"name":"f(x)","type":"function","label":"13","color":"#ffc107","settings":{},"_hash":0.48362241571415243,"funcBody":"var period = time % 1500;\nreturn period < 500;"},{"name":"f(x)","type":"function","label":"29","color":"#607d8b","settings":{},"_hash":0.7217670147518815,"funcBody":"var period = time % 1500;\nreturn period >= 500 && period < 1000;"}]}],"timewindow":{"realtime":{"timewindowMs":60000}}}"} | Raspberry Pi GPIO Panel | 13814000-1dd2-11b2-8080-808080808080 |
| da47b860-e881-11ea-a452-0bb049e7ba49 | 1598545499878 | raspberry_pi_gpio_control | gpio_widgets | {"type":"rpc","sizeX":6,"sizeY":10.5,"resources":[],"templateHtml":"<fieldset class="gpio-panel" style="height: 100%;">\n <section class="gpio-row" fxLayout="row" *ngFor="let row of rows" \n [ngStyle]="{'height': prefferedRowHeight+'px'}">\n <section fxFlex fxLayout="row" *ngFor="let cell of row; let $index = index">\n <section fxLayout="row" fxFlex *ngIf="cell" fxLayoutAlign="{{$index===0 ? 'end center' : 'start center'}}">\n <span class="gpio-left-label" [fxShow]="$index===0">{{ cell.label }}\n <section fxLayout="row" class="switch-panel" fxLayoutAlign="start center" [ngClass]="$index===0 ? 'col-0' : 'col-1'"\n [ngStyle]="{'height': prefferedRowHeight+'px', 'backgroundColor': switchPanelBackgroundColor }">\n <span class="pin" [fxShow]="$index===0">{{cell.pin}}\n <span fxFlex [fxShow]="$index===1">\n <mat-slide-toggle\n [disabled]="!rpcEnabled || executingRpcRequest"\n [checked]="cell.enabled" \n (change)="gpioToggleChange($event, cell)" \n (click)="gpioClick($event, cell)">\n \n <span fxFlex [fxShow]="$index===0">\n <span class="pin" [fxShow]="$index===1">{{cell.pin}}\n \n <span class="gpio-right-label" [fxShow]="$index===1">{{ cell.label }}\n \n <section fxLayout="row" fxFlex *ngIf="!cell">\n <span fxFlex [fxShow]="$index===0">\n <span class="switch-panel"\n [ngStyle]="{'height': prefferedRowHeight+'px', 'backgroundColor': switchPanelBackgroundColor }">\n <span fxFlex [fxShow]="$index===1">\n \n \n \n <span class="error" style="position: absolute; bottom: 5px;" [fxShow]="rpcErrorText">{{rpcErrorText}}\n <mat-progress-bar [fxShow]="executingRpcRequest" style="position: absolute; bottom: 0;" mode="indeterminate">\n","templateCss":".error {\n font-size: 14px !important;\n color: maroon;/*rgb(250,250,250);*/\n background-color: transparent;\n padding: 6px;\n}\n\n.error span {\n margin: auto;\n}\n\n.gpio-panel {\n padding-top: 10px;\n white-space: nowrap;\n}\n\n.gpio-panel section[fxflex] {\n min-width: 0px;\n}\n\n.switch-panel {\n margin: 0;\n height: 32px;\n width: 66px;\n min-width: 66px;\n}\n\n.switch-panel mat-slide-toggle {\n margin: 0;\n width: 36px;\n min-width: 36px;\n}\n\n.switch-panel.col-0 mat-slide-toggle {\n margin-left: 8px;\n margin-right: 4px;\n}\n\n.switch-panel.col-1 mat-slide-toggle {\n margin-left: 4px;\n margin-right: 8px;\n}\n\n.gpio-row {\n height: 32px;\n}\n\n.pin {\n margin-top: auto;\n margin-bottom: auto;\n color: white;\n font-size: 12px;\n width: 16px;\n min-width: 16px;\n}\n\n.switch-panel.col-0 .pin {\n margin-left: auto;\n padding-left: 2px;\n text-align: right;\n}\n\n.switch-panel.col-1 .pin {\n margin-right: auto;\n \n text-align: left;\n}\n\n.gpio-left-label {\n margin-right: 8px;\n}\n\n.gpio-right-label {\n margin-left: 8px;\n}","controllerScript":"var namespace;\nvar cssParser = new cssjs();\n\nself.onInit = function() {\n var utils = self.ctx.$injector.get(self.ctx.servicesMap.get('utils'));\n namespace = 'gpio-control-' + utils.guid();\n cssParser.testMode = false;\n cssParser.cssPreviewNamespace = namespace;\n self.ctx.$container.addClass(namespace);\n self.ctx.ngZone.run(function() {\n init(); \n });\n}\n\nfunction init() {\n \n var i, gpio;\n var scope = self.ctx.$scope;\n var settings = self.ctx.settings;\n scope.gpioList = [];\n for (var g = 0; g < settings.gpioList.length; g++) {\n gpio = settings.gpioList[g];\n scope.gpioList.push(\n {\n row: gpio.row,\n col: gpio.col,\n pin: gpio.pin,\n label: gpio.label,\n enabled: false\n }\n );\n }\n\n scope.requestTimeout = settings.requestTimeout || 1000;\n\n scope.switchPanelBackgroundColor = settings.switchPanelBackgroundColor || tinycolor('green').lighten(2).toRgbString();\n\n scope.gpioStatusRequest = {\n method: "getGpioStatus",\n paramsBody: "{}"\n };\n \n if (settings.gpioStatusRequest) {\n scope.gpioStatusRequest.method = settings.gpioStatusRequest.method || scope.gpioStatusRequest.method;\n scope.gpioStatusRequest.paramsBody = settings.gpioStatusRequest.paramsBody || scope.gpioStatusRequest.paramsBody;\n }\n \n scope.gpioStatusChangeRequest = {\n method: "setGpioStatus",\n paramsBody: "{\n \"pin\": \"{$pin}\",\n \"enabled\": \"{$enabled}\"\n}"\n };\n \n if (settings.gpioStatusChangeRequest) {\n scope.gpioStatusChangeRequest.method = settings.gpioStatusChangeRequest.method || scope.gpioStatusChangeRequest.method;\n scope.gpioStatusChangeRequest.paramsBody = settings.gpioStatusChangeRequest.paramsBody || scope.gpioStatusChangeRequest.paramsBody;\n }\n \n scope.parseGpioStatusFunction = "return body[pin] === true;";\n \n if (settings.parseGpioStatusFunction && settings.parseGpioStatusFunction.length > 0) {\n scope.parseGpioStatusFunction = settings.parseGpioStatusFunction;\n }\n \n scope.parseGpioStatusFunction = new Function("body, pin", scope.parseGpioStatusFunction);\n \n function requestGpioStatus() {\n self.ctx.controlApi.sendTwoWayCommand(scope.gpioStatusRequest.method, \n scope.gpioStatusRequest.paramsBody, \n scope.requestTimeout)\n .subscribe(\n function success(responseBody) {\n for (var g = 0; g < scope.gpioList.length; g++) {\n var gpio = scope.gpioList[g];\n var enabled = scope.parseGpioStatusFunction.apply(this, [responseBody, gpio.pin]);\n gpio.enabled = enabled; \n self.ctx.detectChanges();\n }\n }\n );\n }\n \n function changeGpioStatus(gpio) {\n var pin = gpio.pin + '';\n var enabled = !gpio.enabled;\n enabled = enabled === true ? 'true' : 'false';\n var paramsBody = scope.gpioStatusChangeRequest.paramsBody;\n var requestBody = JSON.parse(paramsBody.replace("\"{$pin}\"", pin).replace("\"{$enabled}\"", enabled));\n self.ctx.controlApi.sendTwoWayCommand(scope.gpioStatusChangeRequest.method, \n requestBody, scope.requestTimeout)\n .subscribe(\n function success(responseBody) {\n var enabled = scope.parseGpioStatusFunction.apply(this, [responseBody, gpio.pin]);\n gpio.enabled = enabled;\n self.ctx.detectChanges();\n }\n );\n }\n \n scope.gpioCells = {};\n var rowCount = 0;\n for (i = 0; i < scope.gpioList.length; i++) {\n gpio = scope.gpioList[i];\n scope.gpioCells[gpio.row+'*'+gpio.col] = gpio;\n rowCount = Math.max(rowCount, gpio.row+1);\n }\n \n scope.prefferedRowHeight = 32;\n scope.rows = [];\n for (i = 0; i < rowCount; i++) {\n var row = [];\n for (var c =0; c<2;c++) {\n if (scope.gpioCells[i+'*'+c]) {\n row[c] = scope.gpioCells[i+'_'+c];\n } else {\n row[c] = null;\n }\n }\n scope.rows.push(row);\n }\n\n scope.gpioClick = function($event, gpio) {\n if (scope.rpcEnabled && !scope.executingRpcRequest) {\n changeGpioStatus(gpio);\n }\n };\n \n scope.gpioToggleChange = function($event, gpio) {\n gpio.enabled = !$event.checked;\n $event.source.toggle();\n self.ctx.detectChanges();\n }\n \n if (scope.rpcEnabled) {\n requestGpioStatus(); \n }\n \n self.onResize();\n}\n\nself.onResize = function() {\n var scope = self.ctx.$scope;\n var rowCount = scope.rows.length;\n var prefferedRowHeight = (self.ctx.height - 35)/rowCount;\n prefferedRowHeight = Math.min(32, prefferedRowHeight);\n prefferedRowHeight = Math.max(12, prefferedRowHeight);\n scope.prefferedRowHeight = prefferedRowHeight;\n var ratio = prefferedRowHeight/32;\n \n var css = '.mat-slide-toggle .mat-slide-toggle-bar {\n' +\n ' height: ' + 14*ratio+'px;\n'+\n ' width: ' + 36*ratio+'px;\n'+\n '}\n';\n css += '.mat-slide-toggle .mat-slide-toggle-thumb-container {\n' +\n ' height: ' + 20*ratio+'px;\n'+\n ' width: ' + 20*ratio+'px;\n'+\n '}\n';\n css += '.mat-slide-toggle .mat-slide-toggle-thumb {\n' +\n ' height: ' + 20*ratio+'px;\n'+\n ' width: ' + 20*ratio+'px;\n'+\n '}\n';\n css += '.mat-slide-toggle .mat-slide-toggle-ripple {\n' +\n ' height: ' + 40*ratio+'px;\n'+\n ' width: ' + 40*ratio+'px;\n'+\n ' top: calc(50% - '+20*ratio+'px);\n'+\n ' left: calc(50% - '+20*ratio+'px);\n'+\n '}\n';\n css += '.gpio-left-label, .gpio-right-label {\n' +\n ' font-size: ' + 16*ratio+'px;\n'+\n '}\n';\n var pinsFontSize = Math.max(9, 12*ratio);\n css += '.pin {\n' +\n ' font-size: ' + pinsFontSize+'px;\n'+\n '}\n';\n\n cssParser.createStyleElement(namespace, css);\n \n self.ctx.detectChanges();\n}\n\nself.onDestroy = function() {\n}\n","settingsSchema":"{\n "schema": {\n "type": "object",\n "title": "Settings",\n "properties": {\n "gpioList": {\n "title": "Gpio switches",\n "type": "array",\n "minItems" : 1,\n "items": {\n "title": "Gpio switch",\n "type": "object",\n "properties": {\n "pin": {\n "title": "Pin",\n "type": "number"\n },\n "label": {\n "title": "Label",\n "type": "string"\n },\n "row": {\n "title": "Row",\n "type": "number"\n },\n "col": {\n "title": "Column",\n "type": "number"\n }\n },\n "required": ["pin", "label", "row", "col"]\n }\n },\n "requestTimeout": {\n "title": "RPC request timeout",\n "type": "number",\n "default": 500\n },\n "switchPanelBackgroundColor": {\n "title": "Switches panel background color",\n "type": "string",\n "default": "#008a00"\n },\n "gpioStatusRequest": {\n "title": "GPIO status request",\n "type": "object",\n "properties": {\n "method": {\n "title": "Method name",\n "type": "string",\n "default": "getGpioStatus"\n },\n "paramsBody": {\n "title": "Method body",\n "type": "string",\n "default": "{}"\n }\n },\n "required": ["method", "paramsBody"]\n },\n "gpioStatusChangeRequest": {\n "title": "GPIO status change request",\n "type": "object",\n "properties": {\n "method": {\n "title": "Method name",\n "type": "string",\n "default": "setGpioStatus"\n },\n "paramsBody": {\n "title": "Method body",\n "type": "string",\n "default": "{\n \"pin\": \"{$pin}\",\n \"enabled\": \"{$enabled}\"\n}"\n }\n },\n "required": ["method", "paramsBody"]\n },\n "parseGpioStatusFunction": {\n "title": "Parse gpio status function",\n "type": "string",\n "default": "return body[pin] === true;"\n } \n },\n "required": ["gpioList", \n "requestTimeout",\n "switchPanelBackgroundColor",\n "gpioStatusRequest",\n "gpioStatusChangeRequest",\n "parseGpioStatusFunction"]\n },\n "form": [\n "gpioList",\n "requestTimeout",\n {\n "key": "switchPanelBackgroundColor",\n "type": "color"\n },\n {\n "key": "gpioStatusRequest",\n "items": [\n "gpioStatusRequest.method",\n {\n "key": "gpioStatusRequest.paramsBody",\n "type": "json"\n }\n ]\n },\n {\n "key": "gpioStatusChangeRequest",\n "items": [\n "gpioStatusChangeRequest.method",\n {\n "key": "gpioStatusChangeRequest.paramsBody",\n "type": "json"\n }\n ]\n },\n {\n "key": "parseGpioStatusFunction",\n "type": "javascript"\n }\n ]\n}","dataKeySettingsSchema":"{}\n","defaultConfig":"{"targetDeviceAliases":[],"showTitle":true,"backgroundColor":"#fff","color":"rgba(0, 0, 0, 0.87)","padding":"0px","settings":{"parseGpioStatusFunction":"return body[pin] === true;","gpioStatusChangeRequest":{"method":"setGpioStatus","paramsBody":"{\n \"pin\": \"{$pin}\",\n \"enabled\": \"{$enabled}\"\n}"},"requestTimeout":500,"switchPanelBackgroundColor":"#008a00","gpioStatusRequest":{"method":"getGpioStatus","paramsBody":"{}"},"gpioList":[{"pin":7,"label":"GPIO 4 (GPCLK0)","row":3,"col":0,"_uniqueKey":0},{"pin":11,"label":"GPIO 17","row":5,"col":0,"_uniqueKey":1},{"pin":12,"label":"GPIO 18","row":5,"col":1,"_uniqueKey":2},{"_uniqueKey":3,"pin":13,"label":"GPIO 27","row":6,"col":0},{"_uniqueKey":4,"pin":15,"label":"GPIO 22","row":7,"col":0},{"_uniqueKey":5,"pin":16,"label":"GPIO 23","row":7,"col":1},{"_uniqueKey":6,"pin":18,"label":"GPIO 24","row":8,"col":1},{"_uniqueKey":7,"pin":22,"label":"GPIO 25","row":10,"col":1},{"_uniqueKey":8,"pin":29,"label":"GPIO 5","row":14,"col":0},{"_uniqueKey":9,"pin":31,"label":"GPIO 6","row":15,"col":0},{"_uniqueKey":10,"pin":32,"label":"GPIO 12","row":15,"col":1},{"_uniqueKey":11,"pin":33,"label":"GPIO 13","row":16,"col":0},{"_uniqueKey":12,"pin":35,"label":"GPIO 19","row":17,"col":0},{"_uniqueKey":13,"pin":36,"label":"GPIO 16","row":17,"col":1},{"_uniqueKey":14,"pin":37,"label":"GPIO 26","row":18,"col":0},{"_uniqueKey":15,"pin":38,"label":"GPIO 20","row":18,"col":1},{"_uniqueKey":16,"pin":40,"label":"GPIO 21","row":19,"col":1}]},"title":"Raspberry Pi GPIO Control"}"} | Raspberry Pi GPIO Control | 13814000-1dd2-11b2-8080-808080808080 |

#### widget_bundle 表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 编号 |
| created_time | bigint | 创建时间 |
| alias | varchar(255) | 别名 |
| search_text | varchar(255) | 搜索关键字 |
| tenant_id | uuid | 租户编号 |
| title | varchar(255) | 名称 |

数据
| id | created_time | alias | search_text | tenant_id | title |
| --- | --- | --- | --- | --- | --- |
| da2da0b0-e881-11ea-a452-0bb049e7ba49 | 1598545499707 | charts | charts | 13814000-1dd2-11b2-8080-808080808080 | Charts |
| da41ec00-e881-11ea-a452-0bb049e7ba49 | 1598545499840 | gpio_widgets | gpio widgets | 13814000-1dd2-11b2-8080-808080808080 | GPIO widgets |
| da49b430-e881-11ea-a452-0bb049e7ba49 | 1598545499891 | maps_v2 | maps | 13814000-1dd2-11b2-8080-808080808080 | Maps |

### 数据模型之设备相关表结构设计

![](https://upload-images.jianshu.io/upload_images/1662509-a44ce5868d222f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### device 设备表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 设备编号 |
| created_time | bigint | 创建时间 |
| additional_info | varchar | 额外信息 |
| customer_id | uuid | 客户id |
| type | varchar(255) | 类型 |
| name | varchar(255) | 名称 |
| label | varchar(255) | 标签 |
| search_text | varchar(255) | 搜素关键字 |
| tenant_id | uuid | 租户编号 |

数据
| id | created_time | additional_info | customer_id | type | name | label | search_text | tenant_id |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 84818cf0-fe46-11ea-8587-91857935e717 | 1600938941247 | {"gateway":false,"description":"测试设备A - 空调"} | 13814000-1dd2-11b2-8080-808080808080 | test | 测试设备A | air conditioner | 测试设备a | e102f1b0-fcb8-11ea-82f8-9b35f0369853 |
| bb348a90-fe46-11ea-8587-91857935e717 | 1600939033017 | {"gateway":false,"description":"测试设备B - 空调"} | 13814000-1dd2-11b2-8080-808080808080 | test | 测试设备B | air conditioner | 测试设备b | e102f1b0-fcb8-11ea-82f8-9b35f0369853 |

DDL
```sql
CREATE TABLE IF NOT EXISTS device (
    id uuid NOT NULL CONSTRAINT device_pkey PRIMARY KEY,
    created_time bigint NOT NULL,
    additional_info varchar,
    customer_id uuid,
    type varchar(255),
    name varchar(255),
    label varchar(255),
    search_text varchar(255),
    tenant_id uuid,
    CONSTRAINT device_name_unq_key UNIQUE (tenant_id, name)
);
```

#### device_credentials 设备认证令牌表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 编号 |
| created_time | bigint | 创建时间 |
| credentials_id | varchar | 认证令牌编号 |
| credentials_type | varchar(255) | 认证令牌类型 |
| credentials_value | varchar | 认证令牌值 |
| device_id | uuid | 设备编号 |

数据
| id | created_time | credentials_id | credentials_type | credentials_value | device_id |
| --- | --- | --- | --- | --- | --- |
| 8499a8d0-fe46-11ea-8587-91857935e717 | 1600938941405 | wBUv3DVP15v857dg8De5 | ACCESS_TOKEN |  | 84818cf0-fe46-11ea-8587-91857935e717 |
| bb3b4150-fe46-11ea-8587-91857935e717 | 1600939033061 | x4aAaXU0dIkE8jR9ANus | ACCESS_TOKEN |  | bb348a90-fe46-11ea-8587-91857935e717 |

ddl
```sql
CREATE TABLE IF NOT EXISTS device_credentials (
    id uuid NOT NULL CONSTRAINT device_credentials_pkey PRIMARY KEY,
    created_time bigint NOT NULL,
    credentials_id varchar,
    credentials_type varchar(255),
    credentials_value varchar,
    device_id uuid,
    CONSTRAINT device_credentials_id_unq_key UNIQUE (credentials_id),
    CONSTRAINT device_credentials_device_id_unq_key UNIQUE (device_id)
);
```

### 数据模型之规则引擎相关表结构设计

![](https://upload-images.jianshu.io/upload_images/1662509-6ae6bf440b899ef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### rule_node 规则节点表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 设备编号 |
| created_time | bigint | 创建时间 |
| rule_chain_id | uuid | 规则引擎编号 |
| additional_info | varchar | 额外信息 |
| configuration | varchar(10000000) | 配置 |
| type | varchar(255) | 类型 |
| name | varchar(255) | 名称 |
| debug_mode | boolean | debug模式 |
| search_text | varchar(255) | 搜素关键字 |

数据
| id | created_time | rule_chain_id | additional_info | configuration | type | name | debug_mode | search_text |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| e143f250-fcb8-11ea-82f8-9b35f0369853 | 0 | e126f470-fcb8-11ea-82f8-9b35f0369853 | {"layoutX":825,"layoutY":379} | {"jsScript":"return '\nIncoming message:\n' + JSON.stringify(msg) + '\nIncoming metadata:\n' + JSON.stringify(metadata);"} | org.thingsboard.rule.engine.action.TbLogNode | Log Other | false | log other |
| e141a860-fcb8-11ea-82f8-9b35f0369853 | 0 | e126f470-fcb8-11ea-82f8-9b35f0369853 | {"layoutX":825,"layoutY":266} | {"jsScript":"return '\nIncoming message:\n' + JSON.stringify(msg) + '\nIncoming metadata:\n' + JSON.stringify(metadata);"} | org.thingsboard.rule.engine.action.TbLogNode | Log RPC from Device | false | log rpc from device |
| e13f5e70-fcb8-11ea-82f8-9b35f0369853 | 0 | e126f470-fcb8-11ea-82f8-9b35f0369853 | {"layoutX":347,"layoutY":149} | {"version":0} | org.thingsboard.rule.engine.filter.TbMsgTypeSwitchNode | Message Type Switch | false | message type switch |
| e13db0c0-fcb8-11ea-82f8-9b35f0369853 | 0 | e126f470-fcb8-11ea-82f8-9b35f0369853 | {"layoutX":825,"layoutY":52} | {"scope":"CLIENT_SCOPE"} | org.thingsboard.rule.engine.telemetry.TbMsgAttributesNode | Save Client Attributes | false | save client attributes |
| e136fa00-fcb8-11ea-82f8-9b35f0369853 | 0 | e126f470-fcb8-11ea-82f8-9b35f0369853 | {"layoutX":824,"layoutY":156} | {"defaultTTL":0} | org.thingsboard.rule.engine.telemetry.TbMsgTimeseriesNode | Save Timeseries | false | save timeseries |
| e9193a00-008f-11eb-b578-a96e41c6df33 | 1601190365600 | e9123520-008f-11eb-b578-a96e41c6df33 | {"layoutX":824,"layoutY":156} | {"defaultTTL":0} | org.thingsboard.rule.engine.telemetry.TbMsgTimeseriesNode | Save Timeseries | false | save timeseries |

DDL
```sql
CREATE TABLE IF NOT EXISTS rule_node (
    id uuid NOT NULL CONSTRAINT rule_node_pkey PRIMARY KEY,
    created_time bigint NOT NULL,
    rule_chain_id uuid,
    additional_info varchar,
    configuration varchar(10000000),
    type varchar(255),
    name varchar(255),
    debug_mode boolean,
    search_text varchar(255)
);
```

#### rule_chain 规则链表

| 字段 | 类型 | 描述 |
| --- | --- | --- |
| id | uuid | 设备编号 |
| created_time | bigint | 创建时间 |
| additional_info | varchar | 额外信息 |
| configuration | varchar(10000000) | 配置 |
| name | varchar(255) | 名称 |
| first_rule_node_id | uuid | 第一规则节点编号 |
| root | boolean | 根节点 |
| debug_mode | boolean | debug模式 |
| search_text | varchar(255) | 搜素关键字 |
| tenant_id | uuid | 租户编号 |

数据
| id | created_time | additional_info | configuration | name | first_rule_node_id | root | debug_mode | search_text | tenant_id |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| e126f470-fcb8-11ea-82f8-9b35f0369853 | 1600768156983 | {"description":""} | null | Root Rule Chain | e13f5e70-fcb8-11ea-82f8-9b35f0369853 | true | true | root rule chain | e102f1b0-fcb8-11ea-82f8-9b35f0369853 |
| e9123520-008f-11eb-b578-a96e41c6df33 | 1601190365554 | null | null | Root Rule Chain | e91f7b90-008f-11eb-b578-a96e41c6df33 | true | false | root rule chain | e8fdc2c0-008f-11eb-b578-a96e41c6df33 |

DDL
```sql
CREATE TABLE IF NOT EXISTS rule_chain (
    id uuid NOT NULL CONSTRAINT rule_chain_pkey PRIMARY KEY,
    created_time bigint NOT NULL,
    additional_info varchar,
    configuration varchar(10000000),
    name varchar(255),
    first_rule_node_id uuid,
    root boolean,
    debug_mode boolean,
    search_text varchar(255),
    tenant_id uuid
);
```
